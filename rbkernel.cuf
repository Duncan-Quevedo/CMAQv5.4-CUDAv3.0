MODULE RBROUTINES
!*************************************************************************
! Module to hold relevant variables in memory available to all device
! threads. ! Also contains the CUDA kernel and the device subroutines it
! calls.
!*************************************************************************

   USE CUDAFOR

   IMPLICIT NONE

   REAL( 8 ), DEVICE, ALLOCATABLE :: ATOL_D( : )
   REAL( 8 ), DEVICE, ALLOCATABLE :: RTOL_D( : )
   REAL( 8 ), DEVICE, ALLOCATABLE :: ERRMX2_D( : )
   INTEGER, DEVICE, ALLOCATABLE :: IARRAY_D( : )
   INTEGER, DEVICE, ALLOCATABLE :: NUSERAT_D( : )
   INTEGER, DEVICE, ALLOCATABLE :: NKUSERAT_D( :, : )
   INTEGER, DEVICE, ALLOCATABLE :: NREACT_D( : )
   INTEGER, DEVICE, ALLOCATABLE :: IRM2_D( :,:,: )
   INTEGER, DEVICE, ALLOCATABLE :: NPRDCT_D( : )
   REAL( 8 ), DEVICE, ALLOCATABLE :: SC_D( :, : )
   INTEGER, DEVICE, ALLOCATABLE :: NDERIVL_D( :, : )
   INTEGER, DEVICE, ALLOCATABLE :: JARRL_D( :, :, : )
   INTEGER, DEVICE, ALLOCATABLE :: JLIAL_D( :, :, : )
   INTEGER, DEVICE, ALLOCATABLE :: NDERIVP_D( :, : )
   INTEGER, DEVICE, ALLOCATABLE :: JARRP_D( :, :, : )
   INTEGER, DEVICE, ALLOCATABLE :: JPIAL_D( :, :, : )
   INTEGER, DEVICE, ALLOCATABLE :: ICOEFF_D( :, :, : )
   INTEGER, DEVICE, ALLOCATABLE :: JZLO_D( : )
   INTEGER, DEVICE, ALLOCATABLE :: IDEC1LO_D( :, : )
   INTEGER, DEVICE, ALLOCATABLE :: IDEC1HI_D( :, : )
   INTEGER, DEVICE, ALLOCATABLE :: IJDECA_D( : )
   INTEGER, DEVICE, ALLOCATABLE :: IJDECB_D( : )
   INTEGER, DEVICE, ALLOCATABLE :: IKDECA_D( : )
   INTEGER, DEVICE, ALLOCATABLE :: IKDECB_D( : )
   INTEGER, DEVICE, ALLOCATABLE :: KJDECA_D( : )
   INTEGER, DEVICE, ALLOCATABLE :: KJDECB_D( : )
   INTEGER, DEVICE, ALLOCATABLE :: JARRAYPT_D( :, :, : )
   INTEGER, DEVICE, ALLOCATABLE :: JHIZ1_D( :, : )
   INTEGER, DEVICE, ALLOCATABLE :: JHIZ2_D( :, : )
   INTEGER, DEVICE, ALLOCATABLE :: JZEROA_D( : )
   INTEGER, DEVICE, ALLOCATABLE :: JZEROB_D( : )
   INTEGER, DEVICE, ALLOCATABLE :: KZHI0_D( :, : )
   INTEGER, DEVICE, ALLOCATABLE :: KZERO_D( :, : )
   INTEGER, DEVICE, ALLOCATABLE :: KZLO1_D( :, : )
   INTEGER, DEVICE, ALLOCATABLE :: KZHI1_D( :, : )
   INTEGER, DEVICE, ALLOCATABLE :: KZLO2_D( :, : )
   INTEGER, DEVICE, ALLOCATABLE :: KZILCH_D( :, : )
   INTEGER, DEVICE, ALLOCATABLE :: MZHI0_D( :, : )
   INTEGER, DEVICE, ALLOCATABLE :: MZLO1_D( :, : )
   INTEGER, DEVICE, ALLOCATABLE :: MZHI1_D( :, : )
   INTEGER, DEVICE, ALLOCATABLE :: MZLO2_D( :, : )
   INTEGER, DEVICE, ALLOCATABLE :: MZILCH_D( :, : )
   REAL( 8 ), DEVICE, ALLOCATABLE :: ERR( : )
   REAL( 8 ), DEVICE, ALLOCATABLE :: EXPLIC( :,: )
   REAL( 8 ), DEVICE, ALLOCATABLE :: Y_D( :,: )
   REAL( 8 ), DEVICE, ALLOCATABLE :: YDOT_D( :,: )
   REAL( 8 ), DEVICE, ALLOCATABLE :: YP_D( :,: )
   REAL( 8 ), DEVICE, ALLOCATABLE :: K1_D( :,: )
   REAL( 8 ), DEVICE, ALLOCATABLE :: K2_D( :,: )
   REAL( 8 ), DEVICE, ALLOCATABLE :: K3_D( :,: )
   REAL( 8 ), DEVICE, ALLOCATABLE :: RKI_D( :,: )
   REAL( 8 ), DEVICE, ALLOCATABLE :: RXRAT_D( :,: )
   REAL( 8 ), DEVICE, ALLOCATABLE :: CC2_D( :,: )
   REAL( 8 ), DEVICE, ALLOCATABLE :: VDIAG_D( :,: )
   REAL( 8 ), DEVICE, ALLOCATABLE :: BLKTEMP_D( : )
   REAL( 8 ), DEVICE, ALLOCATABLE :: BLKDENS_D( : )

   CONTAINS

   ATTRIBUTES( DEVICE ) SUBROUTINE RBFEVAL( NCSP, YIN,  &
                                             NUMCELLS, NCS2, &
                                             NRXNS, MXRCT, MXPRD, &
                                             ISCHAN, NCS, BLKSIZE, &
                                             NUMB_MECH_SPC, &
                                             NSPECIAL_RXN )

   !***********************************************************************
   !
   !  Function:  Compute YDOT = dc/dt for each species. YDOT is the
   !             net rate of change in species concentrations resulting
   !             from chemical production minus chemical loss.
   !
   !  Preconditions: None
   !                                                                     
   !  Key Subroutines/Functions Called: None
   !
   !***********************************************************************

         IMPLICIT NONE

   !..Includes:

   !..Arguments:
         INTEGER, VALUE :: NCSP          ! Index of mech to use: 1=gas/day, 2=gas/night
         REAL( 8 ) :: YIN( BLKSIZE,NUMB_MECH_SPC )  ! Species concs, ppm
         INTEGER, VALUE :: ISCHAN
         INTEGER, VALUE :: NUMCELLS
         INTEGER, VALUE :: NCS2
         INTEGER, VALUE :: NRXNS
         INTEGER, VALUE :: MXRCT
         INTEGER, VALUE :: MXPRD
         INTEGER, VALUE :: NCS
         INTEGER, VALUE :: BLKSIZE
         INTEGER, VALUE :: NUMB_MECH_SPC
         INTEGER, VALUE :: NSPECIAL_RXN

   !..Parameters: None

   !..External FUNCTIONS: None

   !..Local Variables:
         INTEGER :: ISP              ! Loop index for species
         INTEGER :: ISP1, ISP2, ISP3 ! Pointers to species numbers
         INTEGER :: NP               ! Loop index for number of products
         INTEGER :: NR               ! Loop index for number of reactants
         INTEGER :: NRK              ! Reaction number
         INTEGER :: NRX              ! Loop index for number of reactions
         REAL( 8 ) :: FRACN
         INTEGER :: IX               ! Device thread index

   !***********************************************************************      

         IF ( NSPECIAL_RXN .GT. 0 ) CALL SPECIAL_RATES_D( NUMCELLS, YIN, BLKSIZE, NUMB_MECH_SPC )   ! calculate special rate coefficients
         
   ! ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
   !  Initialize dc/dt
   ! ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

         DO ISP = 1, ISCHAN
            DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
               YDOT_D( IX,ISP ) = 0.0D0
            END DO
         END DO
   ! ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
   !  Loop over reactions to calculate dc/dt
   ! ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

         DO 100 NRX = 1, NUSERAT_D( NCSP )
         
            NRK = NKUSERAT_D( NRX,NCSP )

   !..Calculate reaction rate
            IF ( NREACT_D( NRK ) .EQ. 1 ) THEN
               ISP1 = IRM2_D( NRK, 1, NCS )
               DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
                  RXRAT_D( IX,NRK ) = RKI_D( IX,NRK ) &
                                    * YIN( IX,ISP1 )
               END DO
            ELSE IF ( NREACT_D( NRK ) .EQ. 2 ) THEN
               ISP1 = IRM2_D( NRK,1,NCS )
               ISP2 = IRM2_D( NRK,2,NCS )
               DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
                  RXRAT_D( IX,NRK ) = RKI_D( IX,NRK ) &
                                    * YIN( IX,ISP1 ) &
                                    * YIN( IX,ISP2 )
               END DO
            ELSE IF ( NREACT_D( NRK ) .EQ. 3 ) THEN
               ISP1 = IRM2_D( NRK,1,NCS )
               ISP2 = IRM2_D( NRK,2,NCS )
               ISP3 = IRM2_D( NRK,3,NCS )
               DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
                  RXRAT_D( IX,NRK ) = RKI_D( IX,NRK ) &
                                    * YIN( IX,ISP1 ) &
                                    * YIN( IX,ISP2 ) &
                                    * YIN( IX,ISP3 )
               END DO 
            ELSE IF ( NREACT_D( NRK ) .EQ. 0 ) THEN
               DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
                  RXRAT_D( IX,NRK ) = RKI_D( IX,NRK )
               END DO
            END IF
   !..Subtract loss terms from dc/dt for this reaction 
            DO NR = 1, NREACT_D( NRK )
               ISP1 = IRM2_D( NRK,NR,NCS )
               DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
                  YDOT_D( IX,ISP1 ) = YDOT_D( IX,ISP1 ) &
                                    - RXRAT_D( IX,NRK )
               END DO
            END DO
   !..Add production terms to dc/dt for this reaction
            DO NP = 1, NPRDCT_D( NRK )
               ISP1 = IRM2_D( NRK,NP+3,NCS )
               DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
                  YDOT_D( IX,ISP1 ) = YDOT_D( IX,ISP1 ) &
                                    + SC_D( NRK,NP ) * RXRAT_D( IX,NRK )
               END DO
            END DO
   100   CONTINUE               ! END LOOP OVER REACTIONS
         RETURN
      END

   ATTRIBUTES( DEVICE ) SUBROUTINE RBJACOB( NCSP, YIN, &
                                             ISCHAN, NUMCELLS, &
                                             NCS2, NRXNS, &
                                             MXRR, MXRP, MXRCT, MXPRD, &
                                             BLKSIZE, NCS, NUMB_MECH_SPC )

   !***********************************************************************
   !
   !  Function: Compute the Jacobian matrix, [J] ( Jij = d[dCi/dt]/dCj )
   !
   !  Preconditions: None
   !
   !  Key Subroutines/Functions Called: None
   !
   !***********************************************************************

         IMPLICIT NONE

   !..Includes:

   !..Arguments:
         INTEGER, VALUE :: NCSP         ! Index of chem mech to use; 1=gas/day, 2=gas/night
         REAL( 8 ) :: YIN( BLKSIZE,NUMB_MECH_SPC )    ! Species concs, ppm
         INTEGER, VALUE :: NCS2
         INTEGER, VALUE :: NRXNS
         INTEGER, VALUE :: MXRR
         INTEGER, VALUE :: MXRP
         INTEGER, VALUE :: ISCHAN
         INTEGER, VALUE :: NUMCELLS
         INTEGER, VALUE :: MXRCT
         INTEGER, VALUE :: MXPRD
         INTEGER, VALUE :: BLKSIZE
         INTEGER, VALUE :: NCS
         INTEGER, VALUE :: NUMB_MECH_SPC

   !..Parameters: None

   !..External Functions: None

   !..Local Variables:
         INTEGER :: IALP           ! Pointer to location of PD term in EXPLIC
         INTEGER :: IAR            ! Loop index for non-zero entries in [P]
         INTEGER :: IARP           ! Pointer to location of PD term in [P]
         INTEGER :: IARRY          ! Pointer to end of [P] entries
         INTEGER :: ISCP           ! Pointer to stoichiometric coefficient
         INTEGER :: ISPC           ! Loop index for species
         INTEGER :: JR1, JR2, JR3  ! Pointer to reactant species conc.
         INTEGER :: NL             ! Loop index for loss PD terms
         INTEGER :: NLD            ! Number of loss PD terms for each rxn.
         INTEGER :: NP             ! Loop index for prod PD terms
         INTEGER :: NPD            ! Number of prod PD terms for each rxn.
         INTEGER :: NRK            ! Reaction number
         INTEGER :: NRX            ! Loop index for number of reactions
         INTEGER :: NONDIAG        ! Pointer to end of off-diagonal entries
         INTEGER :: NONDIAG1       ! Pointer to start of diagonal entries

         INTEGER :: IX             ! Device thread index
         
         REAL( 8 ) :: CR2          ! Temporary product for 3 reactant rxns
         REAL( 8 ) :: FRACN        ! Stoichiometric coeff. times b*h

   !***********************************************************************

   ! ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
   !  Zero out Jacobian ( stored in sparse matrix array cc2 )
   ! ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
         IARRY = IARRAY_D( NCSP ) 
         NONDIAG = IARRY - ISCHAN  
         NONDIAG1 = NONDIAG + 1
         DO IAR = 0, NONDIAG
            DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
               CC2_D( IX,IAR ) = 0.0D0
            END DO
         END DO
         DO IAR = NONDIAG1, IARRY
            DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
               CC2_D( IX,IAR ) = 0.0D0
            END DO
         END DO

   ! ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
   !  Loop over reaction rates adding partial derivative terms; EXPLIC
   !  holds the PD terms according to number of reactants
   ! ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
         DO 240 NRX = 1, NUSERAT_D( NCSP )

            NRK = NKUSERAT_D( NRX,NCSP )
            
   !...partial derivative term for reactions with 1 reactant
            IF ( NREACT_D( NRK ) .EQ. 1 ) THEN
               DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
                  EXPLIC( IX,1 ) = RKI_D( IX,NRK )
               END DO

   !...partial derivative terms for reactions with 2 reactants
            ELSE IF ( NREACT_D( NRK ) .EQ. 2 ) THEN
               JR1 = IRM2_D( NRK,1,NCS )
               JR2 = IRM2_D( NRK,2,NCS )
               DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
                  EXPLIC( IX,1 )  = RKI_D( IX,NRK ) &
                                    * YIN( IX,JR2 )
                  EXPLIC( IX,2 )  = RKI_D( IX,NRK ) &
                                    * YIN( IX,JR1 )
               END DO

   !.....partial derivative terms for reactions with 3 reactants
            ELSE IF ( NREACT_D( NRK ) .EQ. 3 ) THEN
               JR1 = IRM2_D( NRK,1,NCS )
               JR2 = IRM2_D( NRK,2,NCS )
               JR3 = IRM2_D( NRK,3,NCS )
               DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
                  CR2 = RKI_D( IX,NRK ) * YIN( IX,JR2 )
                  EXPLIC( IX,1 ) = CR2 * YIN( IX,JR3 )
                  EXPLIC( IX,2 ) = RKI_D( IX,NRK ) &
                                    * YIN( IX,JR1 ) &
                                    * YIN( IX,JR3 ) 
                  EXPLIC( IX,3 ) = CR2 * YIN( IX,JR1 )
               END DO
            END IF

   ! ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
   !  Add PD terms to [J] for this reaction
   ! ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
   !...loss terms
            NLD = NDERIVL_D( NRK,NCSP )         
            DO NL = 1, NLD
               IARP = JARRL_D( NRK,NL,NCSP )
               IALP = JLIAL_D( NRK,NL,NCSP )
               DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
                  CC2_D( IX,IARP ) = CC2_D( IX,IARP ) - EXPLIC( IX,IALP ) 
               END DO
            END DO    ! End loop over loss terms
   !...production terms with stoichiomteric coeff EQ 1.0 and NE 1.0
            NPD = NDERIVP_D( NRK,NCSP )
            DO 220 NP = 1, NPD

               IARP = JARRP_D( NRK,NP,NCSP )
               IALP = JPIAL_D( NRK,NP,NCSP )

               IF ( ICOEFF_D( NRK,NP,NCSP ) .EQ. 0 ) THEN
   !..production terms with unit stoichiometry
                  DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
                     CC2_D( IX,IARP ) = CC2_D( IX,IARP ) + EXPLIC( IX,IALP ) 
                  END DO
               ELSE
   !..production terms with non-unit stoichiometry
                  ISCP = ICOEFF_D( NRK,NP,NCSP )
                  FRACN = SC_D( NRK,ISCP )
                  DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
                     CC2_D( IX,IARP ) = CC2_D( IX,IARP ) + FRACN &
                                       * EXPLIC( IX,IALP )
                  END DO
               END IF
   220      END DO      ! End loop over production terms
   240   END DO      ! End loop over reactions

         RETURN 
      END

   ATTRIBUTES( DEVICE ) SUBROUTINE RBDECOMP( NCSP, ISCHAN, &
                                             NUMCELLS, NCS2, NUMB_MECH_SPC, &
                                             MXCOUNT2, MXARRAY )

   !!***********************************************************************
   !!
   !!  Function:  Decompose the matrix [A] into lower- and upper-
   !!             triangular form to facilitate solution of the set of 
   !!             linear simultaneous equations of the form [A]{x}={b}.
   !!
   !!  Preconditions: None
   !!                                                                     
   !!  Key Subroutines/Functions Called: None
   !!
   !!***********************************************************************

         IMPLICIT NONE
         
   !!..Includes:
         INTEGER, VALUE :: NCSP  ! Index of chem mech to use
                                       ! 1=gas/day, 2=gas/night

   !!..Arguments:
         INTEGER, VALUE :: NCS2
         INTEGER, VALUE :: ISCHAN
         INTEGER, VALUE :: NUMB_MECH_SPC
         INTEGER, VALUE :: MXCOUNT2
         INTEGER, VALUE :: NUMCELLS
         INTEGER, VALUE :: MXARRAY

   !!..Parameters: None

   !!..External Functions: None

   !!..Local Variables:
         INTEGER :: IAR             ! Pointer to diagonal terms
         INTEGER :: IC              ! Loop index for ops in decomp loop 1
         INTEGER :: IDLO            ! Start index for decomp loop 1
         INTEGER :: IDHI            ! End index for decomp loop 1
         INTEGER :: IJ0             ! Pointer to ij term 1 in decomp loop 1
         INTEGER :: IJ1             ! Pointer to ij term 2 in decomp loop 1
         INTEGER :: IJA             ! Pointer to ij term 1 in decomp loop 2
         INTEGER :: IJB             ! Pointer to ij term 2 in decomp loop 2
         INTEGER :: IK0             ! Pointer to ik term 1 in decomp loop 1
         INTEGER :: IK1             ! Pointer to ik term 2 in decomp loop 1
         INTEGER :: J               ! Loop index for number of species
         INTEGER :: JC              ! Loop index for ops in decomp loop 2
         INTEGER :: JHI1            ! End index for 2-term decomp loop 2
         INTEGER :: JHI2            ! End index for 1-term decomp loop 2
         INTEGER :: JLO1            ! Start index for 2-term decomp loop 2
         INTEGER :: JLO2            ! Start index for 1-term decomp loop 2
         INTEGER :: KJ0             ! Pointer to kj term 1 in decomp loop 1
         INTEGER :: KJ1             ! Pointer to kj term 2 in decomp loop 1

         INTEGER IX                 ! Device thread index
      
   !!***********************************************************************      

   !! ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
   !!  First loop of L-U decomposition 
   !! ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
         JHI2 = JZLO_D( NCSP )
         DO 100 J = 1, ISCHAN
            IDLO = IDEC1LO_D( J,NCSP )
            IDHI = IDEC1HI_D( J,NCSP )
            DO IC = IDLO, IDHI
               IJ0 = IJDECA_D( IC )
               IJ1 = IJDECB_D( IC )
               IK0 = IKDECA_D( IC )
               IK1 = IKDECB_D( IC )
               KJ0 = KJDECA_D( IC )
               KJ1 = KJDECB_D( IC )
               DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
                  CC2_D( IX,IJ0 ) = CC2_D( IX,IJ0 ) &
                                 - CC2_D( IX,IK0 ) * CC2_D( IX,KJ0 )
                  CC2_D( IX,IJ1 ) = CC2_D( IX,IJ1 ) &
                                 - CC2_D( IX,IK1 ) * CC2_D( IX,KJ1 )
               END DO
            END DO
   !...vdiag = 1 / current diagonal term of the decomposed matrix
            IAR = JARRAYPT_D( J, J, NCSP )
            DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
               VDIAG_D( IX,J )  = 1.0D0 / CC2_D( IX,IAR )
            END DO
   !! ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
   !!  Second loop of decompostion. The elements of L are divided by the
   !!  diagonal element, and the process is divided into parts to improve
   !!  vectorization.
   !! ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
            JLO1 = JHI2 + 1
            JHI1 = JHI2 + JHIZ1_D( J, NCSP ) 
            JLO2 = JHI1 + 1 
            JHI2 = JHI1 + JHIZ2_D( J, NCSP )
            
   !!...do 2 terms at a time
            DO JC = JLO1, JHI1
               IJA = JZEROA_D( JC )
               IJB = JZEROB_D( JC )
               DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
                  CC2_D( IX,IJA ) = CC2_D( IX,IJA ) * VDIAG_D( IX,J )  
                  CC2_D( IX,IJB ) = CC2_D( IX,IJB ) * VDIAG_D( IX,J )  
               END DO
            END DO
   !!...do 1 term at a time 
            DO JC = JLO2, JHI2 
               IJA = JZEROA_D( JC )
               DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
                  CC2_D( IX,IJA ) = CC2_D( IX,IJA ) * VDIAG_D( IX,J )
               END DO
            END DO
   100   END DO
         RETURN
      END

   ATTRIBUTES( DEVICE ) SUBROUTINE RBSOLVE( NCSP, RHS, ISCHAN, &
                                             NUMCELLS, BLKSIZE, N_SPEC, &
                                             NCS2, MXARRAY, NUMB_MECH_SPC )

   !**********************************************************************
   !
   !  Function:  Solve the set of linear simultaneous equations of the
   !             form [A]{x}={b} using the decomposed lower and upper
   !             triangular matrices [L] and [U]. The subroutine first 
   !             solves for {!} in [L]{!}={b}, and then for {x} in
   !             [U]{x}={!}.
   !
   !  Preconditions: Subroutine DECOMP must have been called
   !                                                                     
   !  Key Subroutines/Functions Called: None
   !
   !***********************************************************************

         IMPLICIT NONE
         
   !..Includes: None
         
   !..Arguments:
         INTEGER, VALUE ::  NCSP        ! Index of chem mech to use: 1=gas/day, 2=gas/night
         REAL( 8 ) ::  RHS( BLKSIZE,N_SPEC )  ! Right hand side = {b}
         INTEGER, VALUE :: ISCHAN
         INTEGER, VALUE :: NCS2
         INTEGER, VALUE :: MXARRAY
         INTEGER, VALUE :: NUMCELLS
         INTEGER, VALUE :: BLKSIZE
         INTEGER, VALUE :: N_SPEC
         INTEGER, VALUE :: NUMB_MECH_SPC

   !..Parameters: None

   !..External Functions: None

   !..Local Variables:
         INTEGER :: I                        ! Loop index for number of species
         INTEGER :: IJ                       ! Counter of # of terms summed
         INTEGER :: IJ0, IJ1, IJ2,  &        ! Pointers to location of ij entries in
               IJ3, IJ4                      ! decomposed matrix
         INTEGER :: J, J1, J2, J3, J4        ! Pointers to species # for dc/dt
         INTEGER :: JZ                       ! Loop index inner backsub loops

         INTEGER IX                          ! Device thread index

   !***********************************************************************

   ! ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
   !  Back-substition loop 1
   ! ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
         IJ = 1 
         DO 60 I = 1, ISCHAN
         
   !.....sum 5 terms at a time
            DO JZ = 1, KZHI0_D( I, NCSP ), 5     
               IJ0 = IJ 
               IJ1 = IJ + 1
               IJ2 = IJ + 2 
               IJ3 = IJ + 3 
               IJ4 = IJ + 4 
               J   = KZERO_D( IJ0,NCSP )
               J1  = KZERO_D( IJ1,NCSP )
               J2  = KZERO_D( IJ2,NCSP )
               J3  = KZERO_D( IJ3,NCSP )
               J4  = KZERO_D( IJ4,NCSP )
               IJ = IJ + 5
               DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
                  RHS( IX,I ) = RHS( IX,I ) &
                                 - CC2_D( IX,IJ0 ) * RHS( IX, J ) &
                                 - CC2_D( IX,IJ1 ) * RHS( IX,J1 ) &
                                 - CC2_D( IX,IJ2 ) * RHS( IX,J2 ) &
                                 - CC2_D( IX,IJ3 ) * RHS( IX,J3 ) &
                                 - CC2_D( IX,IJ4 ) * RHS( IX,J4 )
               END DO
            END DO
   !.....sum 2 terms at a time
            DO JZ = KZLO1_D( I,NCSP ), KZHI1_D( I,NCSP ), 2    
               IJ0 = IJ 
               IJ1 = IJ + 1
               J   = KZERO_D( IJ0,NCSP )
               J1  = KZERO_D( IJ1,NCSP )
               IJ = IJ + 2
               DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
                  RHS( IX,I ) = RHS( IX,I ) &
                                 - CC2_D( IX,IJ0 ) * RHS( IX, J ) &
                                 - CC2_D( IX,IJ1 ) * RHS( IX,J1 )
               END DO
            END DO
   !.....sum 1 term at a time
            DO JZ = KZLO2_D( I,NCSP ), KZILCH_D( I,NCSP )    
               IJ0 = IJ
               J   = KZERO_D( IJ0,NCSP )
               IJ = IJ + 1
               DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
                  RHS( IX,I ) = RHS( IX,I ) &
                                 - CC2_D( IX,IJ0 ) * RHS( IX,J )
               END DO
            END DO
   60    CONTINUE
   
   ! ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
   !  Back-substitution loop 2
   ! ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
         DO 180 I = ISCHAN, 1, -1

   !...sum 5 terms at a time
            DO JZ = 1, MZHI0_D( I,NCSP ), 5   
               IJ0 = IJ
               IJ1 = IJ + 1
               IJ2 = IJ + 2 
               IJ3 = IJ + 3 
               IJ4 = IJ + 4 
               J   = KZERO_D( IJ0,NCSP )
               J1  = KZERO_D( IJ1,NCSP )
               J2  = KZERO_D( IJ2,NCSP )
               J3  = KZERO_D( IJ3,NCSP )
               J4  = KZERO_D( IJ4,NCSP )
               IJ = IJ + 5
               DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
                  RHS( IX,I ) = RHS( IX,I ) &
                                 - CC2_D( IX,IJ0 ) * RHS( IX, J ) &
                                 - CC2_D( IX,IJ1 ) * RHS( IX,J1 ) &
                                 - CC2_D( IX,IJ2 ) * RHS( IX,J2 ) &
                                 - CC2_D( IX,IJ3 ) * RHS( IX,J3 ) &
                                 - CC2_D( IX,IJ4 ) * RHS( IX,J4 )
               END DO
            END DO
   !...sum 2 terms at a time 
            DO JZ = MZLO1_D( I,NCSP ), MZHI1_D( I,NCSP ), 2 
               IJ0 = IJ 
               IJ1 = IJ + 1
               J   = KZERO_D( IJ0,NCSP )
               J1  = KZERO_D( IJ1,NCSP )
               IJ = IJ + 2
               DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
                  RHS( IX,I ) = RHS( IX,I ) &
                                 - CC2_D( IX,IJ0 ) * RHS( IX, J )  &
                                 - CC2_D( IX,IJ1 ) * RHS( IX,J1 ) 
               END DO
            END DO
   !...sum 1 term at a time
            DO JZ = MZLO2_D( I,NCSP ), MZILCH_D( I,NCSP ) 
               IJ0 = IJ 
               J   = KZERO_D( IJ0,NCSP )
               IJ = IJ + 1 
               DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
                  RHS( IX,I ) = RHS( IX,I ) &
                                 - CC2_D( IX,IJ0 ) * RHS( IX,J ) 
               END DO
            END DO
   !...adjust diagonal element
            DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
               RHS( IX,I ) = RHS( IX,I ) * VDIAG_D( IX,I )
            END DO
   180   CONTINUE
         RETURN
         END

   ATTRIBUTES( DEVICE ) SUBROUTINE SPECIAL_RATES_D( NUMCELLS, YIN, BLKSIZE, NUMB_MECH_SPC )
! Purpose: calculate special rate operators and update
!         appropriate rate constants

       IMPLICIT NONE

! Arguments:
       INTEGER,      INTENT( IN  )   :: NUMCELLS        ! Number of cells in block 
       REAL( 8 ),    INTENT( IN )    :: YIN( BLKSIZE,NUMB_MECH_SPC )       ! species concs
       INTEGER :: BLKSIZE
       INTEGER :: NUMB_MECH_SPC
! Local:
       REAL( 8 ), PARAMETER :: DENSITY_TO_NUMBER = 2.07930D+19 ! Kg/m3 to molecules/cm3

       INTEGER   :: IX            ! Device thread index
       REAL( 8 ) :: INV_TEMP
       REAL( 8 ) :: CAIR
       REAL( 8 ) :: CFACT         ! scales operator if not multiplied by RKI, cm^3/(molecule) to 1/(ppm)
       REAL( 8 ) :: CFACT_SQU     ! scales operator if not multiplied by RKI, cm^6/(molec^2) to 1/(ppm^2)
! special rate operators listed below

       DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
          INV_TEMP  = 1.0D0 / BLKTEMP_D( IX )
          CAIR      = DENSITY_TO_NUMBER * BLKDENS_D( IX )
          CFACT     = 1.0D-06 * CAIR
          CFACT_SQU = 1.0D-12 * CAIR * CAIR


! define special rate operators


! define rate constants in terms of special rate operators 

       END DO

       RETURN
       END SUBROUTINE SPECIAL_RATES_D

ATTRIBUTES( GLOBAL ) SUBROUTINE RBKERNEL( CHEMSTEP, NCSP, LORDERING, ISCHAN,   &
                                          IDIAGBEG, DTSTART, OFFSET,   &
                                          BLKSIZE, NUMCELLS, N_SPEC, C21, C31, &
                                          C32, B1, B2, B3, D1, D2, D3, UROUND, &
                                          GROW, CONMIN, FACMIN, FACMAX, &
                                          FACONE, DTMAX, DTMIN, MXCELLS, NCS2,  &
                                          NUMB_MECH_SPC, RNSPEC, RGAM, &
                                          NRXNS, MXRCT, MXPRD, MXRR, MXRP, &
                                          MXCOUNT2, MXARRAY, NCS, &
                                          NSPECIAL_RXN )

   IMPLICIT NONE

!*************************************************************************
! The s-stage Rosenbrock method solves the following equations
!                        s
!         Y(n+1) = Yn + SUM( Bi * Ki) 
!                       i=1
!     where
!                          i-1                          i
!         Ki = H * F[ Yn + SUM( Aij * Kj ) ] + H * J * SUM( GAMMAij * Kj ) 
!                          j=1                         j=1
!
! See Sandu et al. for details and the values of Bi, GAMMAij, Aij, etc.
!
! For computational efficiency, the equations are re-arranged as  
! follows (e.g., see Press, Numerical Recipes, Chap 16 on ODEs )
!
!     Gi = SUM( GAMMAij * Kj ) + GAMMA * Ki  i=1,...s
!
!    [ I / GAMMA H - J ] G1 = F[ Yn ]
!    [ I / GAMMA H - J ] G2 = F[ Yn + A21 * G1 ] + ( C21 * G1 ) / H
!    [ I / GAMMA H - J ] G3 = F[ Yn + A31 * G1 + A32 * G2 ] + 
!                              ( C31 * G1 + C32 G2 ) / H   
! 
! The code below sequentially calculates the Gi, and then computes
! Y(n+1) via the first formula.  Note that the parameter values will be
! different from those shown in Sandu et al. because the code computes
! Gi instead of Ki
!*************************************************************************

!  Arguments
   REAL( 8 ), VALUE :: CHEMSTEP
   INTEGER, VALUE :: NCS
   INTEGER, VALUE :: NCSP
   LOGICAL, VALUE :: LORDERING
   INTEGER, VALUE :: ISCHAN
   INTEGER , VALUE:: IDIAGBEG
   INTEGER, VALUE :: OFFSET
   REAL( 8 ), VALUE :: RGAM
   INTEGER, VALUE :: BLKSIZE
   INTEGER, VALUE :: NUMCELLS
   INTEGER, VALUE :: N_SPEC
   REAL( 8 ), VALUE :: C21
   REAL( 8 ), VALUE :: C31
   REAL( 8 ), VALUE :: C32
   REAL( 8 ), VALUE :: B1
   REAL( 8 ), VALUE :: B2
   REAL( 8 ), VALUE :: B3
   REAL( 8 ), VALUE :: D1
   REAL( 8 ), VALUE :: D2
   REAL( 8 ), VALUE :: D3
   REAL( 8 ), VALUE :: UROUND
   REAL( 8 ), VALUE :: GROW
   REAL( 8 ), VALUE :: CONMIN
   REAL( 8 ), VALUE :: FACMIN
   REAL( 8 ), VALUE :: FACMAX
   REAL( 8 ), VALUE :: FACONE
   REAL( 8 ), VALUE :: DTMAX
   REAL( 8 ), VALUE :: DTMIN
   REAL( 8 ), VALUE :: DTSTART
   INTEGER, VALUE :: MXCELLS
   INTEGER, VALUE :: NCS2
   INTEGER, VALUE :: NUMB_MECH_SPC
   REAL( 8 ), VALUE :: RNSPEC
   INTEGER, VALUE :: NRXNS
   INTEGER, VALUE :: MXRCT
   INTEGER, VALUE :: MXPRD
   INTEGER, VALUE :: MXRR
   INTEGER, VALUE :: MXRP
   INTEGER, VALUE :: MXCOUNT2
   INTEGER, VALUE :: MXARRAY
   INTEGER, VALUE :: NSPECIAL_RXN

!  Local variables
   REAL( 8 ) :: DT
   REAL( 8 ) :: TNOW
   LOGICAL :: LPASS
   INTEGER JSPC
   REAL( 8 ) YLOWEPS
   REAL( 8 ) ERRYMAX
   REAL( 8 ) TEND
   REAL( 8 ) DTINV
   REAL( 8 ) GDTINV
   INTEGER J
   INTEGER N
   REAL( 8 ) X21, X31, X32
   REAL( 8 ) YTOL
   REAL( 8 ) MAXERR
   REAL( 8 ) DTFAC
   INTEGER IX

!*************************************************************************

   DT = MAX( DTMIN, DTSTART )
   TNOW = 0.0D0
   LPASS = .FALSE.

    DO 100 WHILE ( TNOW .LT. CHEMSTEP )

         CALL RBFEVAL( NCSP, Y_D,  &
                        NUMCELLS, NCS2, &
                        NRXNS, MXRCT, MXPRD, &
                        ISCHAN, NCS, BLKSIZE, &
                        NUMB_MECH_SPC, &
                        NSPECIAL_RXN )
         
         IF ( LORDERING ) THEN

            DO JSPC = 1, ISCHAN  
               YLOWEPS = ATOL_D( JSPC ) / ( MIN( RTOL_D( JSPC ), 0.003D+00 ) )
               DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
                  ERRYMAX = YDOT_D( IX,JSPC ) &
                          / ( Y_D( IX,JSPC ) + YLOWEPS )
                  ERRMX2_D( OFFSET + IX ) = ERRMX2_D( OFFSET + IX ) &
                                          + ERRYMAX * ERRYMAX
               END DO
            END DO
            RETURN
   
         END IF

         TEND = TNOW + DT 

         IF ( TEND .GT. CHEMSTEP ) THEN
            DT = CHEMSTEP - TNOW
            TEND = CHEMSTEP
         END IF    

         DTINV = 1.0D+00 / DT

         GDTINV = DTINV * RGAM
      
         CALL RBJACOB( NCSP, Y_D, &
                        ISCHAN, NUMCELLS, &
                        NCS2, NRXNS, &
                        MXRR, MXRP, MXRCT, MXPRD, &
                        BLKSIZE, NCS, NUMB_MECH_SPC )
         

         DO J = IDIAGBEG, IARRAY_D( NCSP )
            DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
               CC2_D( IX,J ) = CC2_D( IX,J ) - GDTINV
            END DO
         END DO

         CALL RBDECOMP( NCSP, ISCHAN, &
                        NUMCELLS, NCS2, NUMB_MECH_SPC, &
                        MXCOUNT2, MXARRAY )
         
!   STAGE 1

         DO N = 1, N_SPEC
            DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
               K1_D( IX,N ) = -YDOT_D( IX,N )
            END DO
         END DO      

         CALL RBSOLVE( NCSP, K1_D, ISCHAN, &
                        NUMCELLS, BLKSIZE, N_SPEC, &
                        NCS2, MXARRAY, NUMB_MECH_SPC )

!   STAGE 2

         DO N = 1, N_SPEC
            DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
               YP_D( IX,N ) = Y_D( IX,N ) + K1_D( IX,N )
            END DO
         END DO      

         CALL RBFEVAL( NCSP, YP_D,  &
                        NUMCELLS, NCS2, &
                        NRXNS, MXRCT, MXPRD, &
                        ISCHAN, NCS, BLKSIZE, &
                        NUMB_MECH_SPC, &
                        NSPECIAL_RXN )
         
         X21 = C21 * DTINV
         DO N = 1, N_SPEC
            DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
               K2_D( IX,N ) = -YDOT_D( IX,N ) - X21 * K1_D( IX,N )
            END DO
         END DO      

         CALL RBSOLVE( NCSP, K2_D, ISCHAN, &
                        NUMCELLS, BLKSIZE, N_SPEC, &
                        NCS2, MXARRAY, NUMB_MECH_SPC )
         
!   STAGE 3

         X31 = C31 * DTINV
         X32 = C32 * DTINV
         DO N = 1, N_SPEC
            DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
               K3_D( IX,N ) = -YDOT_D( IX,N ) - X31 * K1_D( IX,N ) - X32 * K2_D( IX,N )
            END DO
         END DO

         CALL RBSOLVE( NCSP, K3_D, ISCHAN, &
                        NUMCELLS, BLKSIZE, N_SPEC, &
                        NCS2, MXARRAY, NUMB_MECH_SPC )
         
!   FINAL SOLUTION

         DO N = 1, N_SPEC
            DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
               YP_D( IX,N ) = Y_D( IX,N ) + B1 * K1_D( IX,N ) &
                            + B2 * K2_D( IX,N ) + B3 * K3_D( IX,N )
            END DO
         END DO

!   ESTIMATE ERROR

         DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
            ERR( IX ) = 0.0D+00
         END DO

         DO N = 1, N_SPEC
            DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
               YTOL = ATOL_D( N ) + RTOL_D( N ) * ABS( YP_D( IX,N ) )
               ERR( IX ) = ERR( IX ) &
                            + ( ( D1 * K1_D( IX,N ) + D2 * K2_D( IX,N ) &
                            + D3 * K3_D( IX,N ) ) / YTOL ) ** 2
           END DO
         END DO

         DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
            ERR( IX ) = SQRT( ERR( IX ) * RNSPEC )
         END DO

         MAXERR = MAX( UROUND, MAXVAL( ERR ) )

         DTFAC = 0.9D+00 / MAXERR ** GROW

        IF ( MAXERR .LE. 1.0D+00 ) THEN

            DO N = 1, NUMB_MECH_SPC
               DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
                  Y_D( IX,N ) = MAX( YP_D( IX,N ), CONMIN )
               END DO
            END DO

            TNOW = TEND
            
            IF ( LPASS ) THEN
               DTFAC = MAX( FACMIN, MIN( DTFAC, FACMAX ) )
            ELSE
               DTFAC = MAX( FACMIN, MIN( DTFAC, FACONE ) )
            END IF

            DT = MIN( DTMAX, MAX( DTMIN, DTFAC * DT ) )
         
            LPASS = .TRUE.

        ELSE

            DT = FACMIN * DT

            LPASS = .FALSE.

        END IF
      CALL SYNCTHREADS()
100 END DO
   CALL SYNCTHREADS()
   RETURN
END SUBROUTINE RBKERNEL
   
END MODULE RBROUTINES

SUBROUTINE KERNELDRIVER( BLKSIZE, Y, RKI, DTSTART, &
                        CHEMSTEP, NCSP, LORDERING, ISCHAN,   &
                        IDIAGBEG, DT, TNOW, LPASS, OFFSET,   &
                        ATOL, RTOL, ERRMX2, RGAM, IARRAY,    &
                        NUMCELLS, N_SPEC, C21, C31, &
                        C32, B1, B2, B3, D1, D2, D3, UROUND, &
                        GROW, CONMIN, FACMIN, FACMAX, &
                        FACONE, DTMAX, DTMIN, MXCELLS, NCS2,  &
                        NUMB_MECH_SPC, RNSPEC, NUSERAT,      &
                        NKUSERAT, NREACT, IRM2, NPRDCT, SC,  &
                        NRXNS, MXRCT, MXPRD, MXRR, MXRP, NDERIVL, &
                        JARRL, JLIAL, NDERIVP, JARRP, JPIAL, ICOEFF, JZLO, IDEC1LO, &
                        IDEC1HI, MXCOUNT2, IJDECA, IJDECB, &
                        IKDECA, IKDECB, KJDECA, KJDECB, JARRAYPT, &
                        JHIZ1, JHIZ2, MXARRAY, JZEROA, JZEROB, &
                        KZHI0, KZERO, KZLO1, KZHI1, KZLO2, &
                        KZILCH, MZHI0, MZLO1, MZHI1, MZLO2, MZILCH, NCS, MPI_COMM_WORLD, &
                        BLKTEMP, BLKDENS, NSPECIAL_RXN )

   USE RBROUTINES
   USE CUDAFOR

   IMPLICIT NONE

!*************************************************************************
! Host routine to allocate and deallocate device memory and invoke
! rbkernel. Called by rbsolver.
!*************************************************************************

!  Arguments
   INTEGER :: BLKSIZE
   REAL( 8 ) :: Y( BLKSIZE, NUMB_MECH_SPC )
   REAL( 8 ) :: RKI( BLKSIZE, NRXNS )
   REAL( 8 ) :: DTSTART
   REAL( 8 ) :: CHEMSTEP
   INTEGER :: NCSP
   LOGICAL :: LORDERING
   INTEGER :: ISCHAN
   INTEGER :: IDIAGBEG
   REAL( 8 ) :: DT
   REAL( 8 ) :: TNOW
   LOGICAL :: LPASS
   INTEGER :: OFFSET
   REAL( 8 ) :: ATOL( NUMB_MECH_SPC )
   REAL( 8 ) :: RTOL( NUMB_MECH_SPC )
   REAL( 8 ) :: ERRMX2( MXCELLS )
   REAL( 8 ) :: RGAM
   INTEGER :: IARRAY( NCS2 )
   INTEGER :: NUMCELLS
   INTEGER :: N_SPEC
   REAL( 8 ) :: C21
   REAL( 8 ) :: C31
   REAL( 8 ) :: C32
   REAL( 8 ) :: B1
   REAL( 8 ) :: B2
   REAL( 8 ) :: B3
   REAL( 8 ) :: D1
   REAL( 8 ) :: D2
   REAL( 8 ) :: D3
   REAL( 8 ) :: UROUND
   REAL( 8 ) :: GROW
   REAL( 8 ) :: CONMIN
   REAL( 8 ) :: FACMIN
   REAL( 8 ) :: FACMAX
   REAL( 8 ) :: FACONE
   REAL( 8 ) :: DTMAX
   REAL( 8 ) :: DTMIN
   INTEGER :: MXCELLS
   INTEGER :: NCS2
   INTEGER :: NUMB_MECH_SPC
   REAL( 8 ) :: RNSPEC
   INTEGER :: NUSERAT( NCS2 )
   INTEGER :: NKUSERAT( NRXNS, NCS2 )
   INTEGER :: NREACT( NRXNS )
   INTEGER :: IRM2( NRXNS,MXRCT+MXPRD,NCS2 )
   INTEGER :: NPRDCT( NRXNS )
   REAL( 8 ) :: SC( NRXNS, MXPRD )
   INTEGER :: NRXNS
   INTEGER :: MXRCT
   INTEGER :: MXPRD
   INTEGER :: MXRR
   INTEGER :: MXRP
   INTEGER :: NDERIVL( NRXNS, NCS2 )
   INTEGER :: JARRL( NRXNS, MXRR, NCS2 )
   INTEGER :: JLIAL( NRXNS, MXRR, NCS2 )
   INTEGER :: NDERIVP( NRXNS, NCS2 )
   INTEGER :: JARRP( NRXNS, MXRP, NCS2 )
   INTEGER :: JPIAL( NRXNS, MXRP, NCS2 )
   INTEGER :: ICOEFF( NRXNS, MXRP, NCS2 )
   INTEGER :: JZLO( NCS2 )
   INTEGER :: IDEC1LO( NUMB_MECH_SPC, NCS2 )
   INTEGER :: IDEC1HI( NUMB_MECH_SPC, NCS2 )
   INTEGER :: MXCOUNT2
   INTEGER :: IJDECA( MXCOUNT2 )
   INTEGER :: IJDECB( MXCOUNT2 )
   INTEGER :: IKDECA( MXCOUNT2 )
   INTEGER :: IKDECB( MXCOUNT2 )
   INTEGER :: KJDECA( MXCOUNT2 )
   INTEGER :: KJDECB( MXCOUNT2 )
   INTEGER :: JARRAYPT( NUMB_MECH_SPC, NUMB_MECH_SPC, NCS2 )
   INTEGER :: JHIZ1( NUMB_MECH_SPC, NCS2 )
   INTEGER :: JHIZ2( NUMB_MECH_SPC, NCS2 )
   INTEGER :: MXARRAY
   INTEGER :: JZEROA( MXARRAY )
   INTEGER :: JZEROB( MXARRAY )
   INTEGER :: KZHI0( NUMB_MECH_SPC, NCS2 )
   INTEGER :: KZERO( MXARRAY, NCS2 )
   INTEGER :: KZLO1( NUMB_MECH_SPC, NCS2 )
   INTEGER :: KZHI1( NUMB_MECH_SPC, NCS2 )
   INTEGER :: KZLO2( NUMB_MECH_SPC, NCS2 )
   INTEGER :: KZILCH( NUMB_MECH_SPC, NCS2 )
   INTEGER :: MZHI0( NUMB_MECH_SPC, NCS2 )
   INTEGER :: MZLO1( NUMB_MECH_SPC, NCS2 )
   INTEGER :: MZHI1( NUMB_MECH_SPC, NCS2 )
   INTEGER :: MZLO2( NUMB_MECH_SPC, NCS2 )
   INTEGER :: MZILCH( NUMB_MECH_SPC, NCS2 )
   INTEGER :: NCS
   INTEGER :: MPI_COMM_WORLD
   REAL( 8 ) :: BLKTEMP( BLKSIZE )
   REAL( 8 ) :: BLKDENS( BLKSIZE )
   INTEGER :: NSPECIAL_RXN

!  Local variables
   TYPE( DIM3 ) :: GRID, TBLOCK
   INTEGER :: ISTAT, MPCOUNT, MAXTHREADS, MAXBLOCKS, MAXWARPS
   TYPE( CUDADEVICEPROP ) :: PROP
   INTEGER :: IERROR, RANK, NPROCS, NDEV, DEVID
   INTEGER( KIND=CUDA_STREAM_KIND ) :: STREAMID

!*************************************************************************

!  Collecting runtime parameters...
   CALL MPI_COMM_RANK( MPI_COMM_WORLD, RANK, IERROR )
   CALL MPI_COMM_SIZE( MPI_COMM_WORLD, NPROCS, IERROR )

   ISTAT = cudaGetDeviceCount( NDEV )
   DEVID = MOD( RANK,NDEV )
   ISTAT = cudaSetDevice( DEVID )

!  Initializing CUDA streams...
   ISTAT = cudaStreamCreate( STREAMID )

!  Allocating device variables...
   ALLOCATE( &
      ATOL_D( NUMB_MECH_SPC ), &
      RTOL_D( NUMB_MECH_SPC ), &
      ERRMX2_D( MXCELLS ), &
      IARRAY_D( NCS2 ), &
      NUSERAT_D( NCS2 ), &
      NKUSERAT_D( NRXNS, NCS2 ), &
      NREACT_D( NRXNS ), &
      IRM2_D( NRXNS,MXRCT+MXPRD,NCS2 ), &
      NPRDCT_D( NRXNS ), &
      SC_D( NRXNS, MXPRD ), &
      NDERIVL_D( NRXNS, NCS2 ), &
      JARRL_D( NRXNS, MXRR, NCS2 ), &
      JLIAL_D( NRXNS, MXRR, NCS2 ), &
      NDERIVP_D( NRXNS, NCS2 ), &
      JARRP_D( NRXNS, MXRP, NCS2 ), &
      JPIAL_D( NRXNS, MXRP, NCS2 ), &
      ICOEFF_D( NRXNS, MXRP, NCS2 ), &
      JZLO_D( NCS2 ), &
      IDEC1LO_D( NUMB_MECH_SPC, NCS2 ), &
      IDEC1HI_D( NUMB_MECH_SPC, NCS2 ), &
      IJDECA_D( MXCOUNT2 ), &
      IJDECB_D( MXCOUNT2 ), &
      IKDECA_D( MXCOUNT2 ), &
      IKDECB_D( MXCOUNT2 ), &
      KJDECA_D( MXCOUNT2 ), &
      KJDECB_D( MXCOUNT2 ), &
      JARRAYPT_D( NUMB_MECH_SPC, NUMB_MECH_SPC, NCS2 ), &
      JHIZ1_D( NUMB_MECH_SPC, NCS2 ), &
      JHIZ2_D( NUMB_MECH_SPC, NCS2 ), &
      JZEROA_D( MXARRAY ), &
      JZEROB_D( MXARRAY ), &
      KZHI0_D( NUMB_MECH_SPC, NCS2 ), &
      KZERO_D( MXARRAY, NCS2 ), &
      KZLO1_D( NUMB_MECH_SPC, NCS2 ), &
      KZHI1_D( NUMB_MECH_SPC, NCS2 ), &
      KZLO2_D( NUMB_MECH_SPC, NCS2 ), &
      KZILCH_D( NUMB_MECH_SPC, NCS2 ), &
      MZHI0_D( NUMB_MECH_SPC, NCS2 ), &
      MZLO1_D( NUMB_MECH_SPC, NCS2 ), &
      MZHI1_D( NUMB_MECH_SPC, NCS2 ), &
      MZLO2_D( NUMB_MECH_SPC, NCS2 ), &
      MZILCH_D( NUMB_MECH_SPC, NCS2 ), &
      EXPLIC( BLKSIZE,3 ), &
      ERR( BLKSIZE ), &
      Y_D( BLKSIZE, NUMB_MECH_SPC ), &
      YDOT_D( BLKSIZE, NUMB_MECH_SPC ), &
      YP_D( BLKSIZE, NUMB_MECH_SPC ), &
      K1_D( BLKSIZE, N_SPEC ), &
      K2_D( BLKSIZE, N_SPEC ), &
      K3_D( BLKSIZE, N_SPEC ), & 
      RKI_D( BLKSIZE, NRXNS ), & 
      RXRAT_D( BLKSIZE, NRXNS ), &
      CC2_D( BLKSIZE, 0:MXARRAY ), &
      VDIAG_D( BLKSIZE, NUMB_MECH_SPC ), &
      BLKTEMP_D( BLKSIZE ), &
      BLKDENS_D( BLKSIZE ) &
   )

!  Copying host variables to device...
   ATOL_D = ATOL
   RTOL_D = RTOL
   ERRMX2_D = ERRMX2
   IARRAY_D = IARRAY
   NUSERAT_D = NUSERAT
   NKUSERAT_D = NKUSERAT
   NREACT_D = NREACT
   IRM2_D = IRM2
   NPRDCT_D = NPRDCT
   SC_D = SC
   NDERIVL_D = NDERIVL
   JARRL_D = JARRL
   JLIAL_D = JLIAL
   NDERIVP_D = NDERIVP
   JARRP_D = JARRP
   JPIAL_D = JPIAL
   ICOEFF_D = ICOEFF
   JZLO_D = JZLO
   IDEC1LO_D = IDEC1LO
   IDEC1HI_D = IDEC1HI
   IJDECA_D = IJDECA
   IJDECB_D = IJDECB
   IKDECA_D = IKDECA
   IKDECB_D = IKDECB
   KJDECA_D = KJDECA
   KJDECB_D = KJDECB
   JARRAYPT_D = JARRAYPT
   JHIZ1_D = JHIZ1
   JHIZ2_D = JHIZ2
   JZEROA_D = JZEROA
   JZEROB_D = JZEROB
   KZHI0_D = KZHI0
   KZERO_D = KZERO
   KZLO1_D = KZLO1
   KZHI1_D = KZHI1
   KZLO2_D = KZLO2
   KZILCH_D = KZILCH
   MZHI0_D = MZHI0
   MZLO1_D = MZLO1
   MZHI1_D = MZHI1
   MZLO2_D = MZLO2
   MZILCH_D = MZILCH
   BLKTEMP_D = BLKTEMP
   BLKDENS_D = BLKDENS
   Y_D = Y
   RKI_D = RKI

!  Collecting hardware properties...
   ISTAT = cudaGetDeviceProperties( PROP, DEVID )
   MPCOUNT = PROP%multiProcessorCount
   MAXTHREADS = PROP%maxThreadsPerMultiProcessor
   MAXBLOCKS = PROP%maxBlocksPerMultiProcessor

!  Defining thread blocks and grids...
   GRID = DIM3( MAXBLOCKS*MPCOUNT*NDEV/NPROCS,1,1 )
   TBLOCK = DIM3( MAXTHREADS/MAXBLOCKS,1,1 )

   ISTAT = cudaStreamSynchronize( STREAMID )

   CALL RBKERNEL<<< GRID,TBLOCK,0,STREAMID >>>( CHEMSTEP, NCSP, LORDERING, ISCHAN,   &
                                                IDIAGBEG, DTSTART, OFFSET,   &
                                                BLKSIZE, NUMCELLS, N_SPEC, C21, C31, &
                                                C32, B1, B2, B3, D1, D2, D3, UROUND, &
                                                GROW, CONMIN, FACMIN, FACMAX, &
                                                FACONE, DTMAX, DTMIN, MXCELLS, NCS2,  &
                                                NUMB_MECH_SPC, RNSPEC, RGAM, &
                                                NRXNS, MXRCT, MXPRD, MXRR, MXRP, &
                                                MXCOUNT2, MXARRAY, NCS, &
                                                NSPECIAL_RXN )

   ISTAT = cudaStreamSynchronize( STREAMID )
   
!  Check for kernel launch errors...
   ISTAT = cudaGetLastError()
   IF ( ISTAT .NE. cudaSuccess ) PRINT *, cudaGetErrorString( ISTAT )


!  Copy relevant device variables back to host...
   ERRMX2 = ERRMX2_D
   Y = Y_D

!  Free device memory...
   DEALLOCATE( &
      Y_D,  &
      YDOT_D,  &
      YP_D, &
      K1_D, &
      K2_D, &
      K3_D, &
      RKI_D,   &
      RXRAT_D, &
      CC2_D,   &
      VDIAG_D, &
      EXPLIC, &
      ERR, &
      ATOL_D, &
      RTOL_D, &
      ERRMX2_D, &
      IARRAY_D, &
      NUSERAT_D, &
      NKUSERAT_D, &
      NREACT_D, &
      IRM2_D, &
      NPRDCT_D, &
      SC_D, &
      NDERIVL_D, &
      JARRL_D, &
      JLIAL_D, &
      NDERIVP_D, &
      JARRP_D, &
      JPIAL_D, &
      ICOEFF_D, &
      JZLO_D, &
      IDEC1LO_D, &
      IDEC1HI_D, &
      IJDECA_D, &
      IJDECB_D, &
      IKDECA_D, &
      IKDECB_D, &
      KJDECA_D, &
      KJDECB_D, &
      JARRAYPT_D, &
      JHIZ1_D, &
      JHIZ2_D, &
      JZEROA_D, &
      JZEROB_D, &
      KZHI0_D, &
      KZERO_D, &
      KZLO1_D, &
      KZHI1_D, &
      KZLO2_D, &
      KZILCH_D, &
      MZHI0_D, &
      MZLO1_D, &
      MZHI1_D, &
      MZLO2_D, &
      MZILCH_D, &
      BLKTEMP_D, &
      BLKDENS_D &
   )

   RETURN

END SUBROUTINE KERNELDRIVER
