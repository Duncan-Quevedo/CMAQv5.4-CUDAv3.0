MODULE RBROUTINES

   USE CUDAFOR

   IMPLICIT NONE

   REAL( 8 ), DEVICE, ALLOCATABLE :: ATOL_D( : )
   REAL( 8 ), DEVICE, ALLOCATABLE :: RTOL_D( : )
   REAL( 8 ), DEVICE, ALLOCATABLE :: ERRMX2_D( : )
   INTEGER, DEVICE, ALLOCATABLE :: IARRAY_D( : )
   INTEGER, DEVICE, ALLOCATABLE :: NUSERAT_D( : )
   INTEGER, DEVICE, ALLOCATABLE :: NKUSERAT_D( :, : )
   INTEGER, DEVICE, ALLOCATABLE :: NREACT_D( : )
   INTEGER, DEVICE, ALLOCATABLE :: IRM2_D( :,:,: )
   INTEGER, DEVICE, ALLOCATABLE :: NPRDCT_D( : )
   REAL( 8 ), DEVICE, ALLOCATABLE :: SC_D( :, : )
   INTEGER, DEVICE, ALLOCATABLE :: NDERIVL_D( :, : )
   INTEGER, DEVICE, ALLOCATABLE :: JARRL_D( :, :, : )
   INTEGER, DEVICE, ALLOCATABLE :: JLIAL_D( :, :, : )
   INTEGER, DEVICE, ALLOCATABLE :: NDERIVP_D( :, : )
   INTEGER, DEVICE, ALLOCATABLE :: JARRP_D( :, :, : )
   INTEGER, DEVICE, ALLOCATABLE :: JPIAL_D( :, :, : )
   INTEGER, DEVICE, ALLOCATABLE :: ICOEFF_D( :, :, : )
   INTEGER, DEVICE, ALLOCATABLE :: JZLO_D( : )
   INTEGER, DEVICE, ALLOCATABLE :: IDEC1LO_D( :, : )
   INTEGER, DEVICE, ALLOCATABLE :: IDEC1HI_D( :, : )
   INTEGER, DEVICE, ALLOCATABLE :: IJDECA_D( : )
   INTEGER, DEVICE, ALLOCATABLE :: IJDECB_D( : )
   INTEGER, DEVICE, ALLOCATABLE :: IKDECA_D( : )
   INTEGER, DEVICE, ALLOCATABLE :: IKDECB_D( : )
   INTEGER, DEVICE, ALLOCATABLE :: KJDECA_D( : )
   INTEGER, DEVICE, ALLOCATABLE :: KJDECB_D( : )
   INTEGER, DEVICE, ALLOCATABLE :: JARRAYPT_D( :, :, : )
   INTEGER, DEVICE, ALLOCATABLE :: JHIZ1_D( :, : )
   INTEGER, DEVICE, ALLOCATABLE :: JHIZ2_D( :, : )
   INTEGER, DEVICE, ALLOCATABLE :: JZEROA_D( : )
   INTEGER, DEVICE, ALLOCATABLE :: JZEROB_D( : )
   INTEGER, DEVICE, ALLOCATABLE :: KZHI0_D( :, : )
   INTEGER, DEVICE, ALLOCATABLE :: KZERO_D( :, : )
   INTEGER, DEVICE, ALLOCATABLE :: KZLO1_D( :, : )
   INTEGER, DEVICE, ALLOCATABLE :: KZHI1_D( :, : )
   INTEGER, DEVICE, ALLOCATABLE :: KZLO2_D( :, : )
   INTEGER, DEVICE, ALLOCATABLE :: KZILCH_D( :, : )
   INTEGER, DEVICE, ALLOCATABLE :: MZHI0_D( :, : )
   INTEGER, DEVICE, ALLOCATABLE :: MZLO1_D( :, : )
   INTEGER, DEVICE, ALLOCATABLE :: MZHI1_D( :, : )
   INTEGER, DEVICE, ALLOCATABLE :: MZLO2_D( :, : )
   INTEGER, DEVICE, ALLOCATABLE :: MZILCH_D( :, : )

   REAL( 8 ), DEVICE, ALLOCATABLE :: ERR( : )
   REAL( 8 ), DEVICE, ALLOCATABLE :: EXPLIC( :,: )

   REAL( 8 ), DEVICE, ALLOCATABLE :: Y_D( :,: )
   REAL( 8 ), DEVICE, ALLOCATABLE :: YDOT_D( :,: )
   REAL( 8 ), DEVICE, ALLOCATABLE :: YP_D( :,: )
   REAL( 8 ), DEVICE, ALLOCATABLE :: K1_D( :,: )
   REAL( 8 ), DEVICE, ALLOCATABLE :: K2_D( :,: )
   REAL( 8 ), DEVICE, ALLOCATABLE :: K3_D( :,: )
   REAL( 8 ), DEVICE, ALLOCATABLE :: RKI_D( :,: )
   REAL( 8 ), DEVICE, ALLOCATABLE :: RXRAT_D( :,: )
   REAL( 8 ), DEVICE, ALLOCATABLE :: CC2_D( :,: )
   REAL( 8 ), DEVICE, ALLOCATABLE :: VDIAG_D( :,: )

   REAL( 8 ), DEVICE, ALLOCATABLE :: BLKTEMP_D( : )
   REAL( 8 ), DEVICE, ALLOCATABLE :: BLKDENS_D( : )

   !REAL( 8 ), DEVICE, ALLOCATABLE :: ERRYMAX( : )
   !REAL( 8 ), DEVICE, ALLOCATABLE :: YTOL( : )

   CONTAINS

   ATTRIBUTES( DEVICE ) SUBROUTINE RBFEVAL( NCSP, YIN,  &
                                             NUMCELLS, NCS2, &
                                             NRXNS, MXRCT, MXPRD, &
                                             ISCHAN, NCS, BLKSIZE, &
                                             NUMB_MECH_SPC, &
                                             NSPECIAL_RXN )

   !***********************************************************************
   !
   !  Function:  Compute YDOT = dc/dt for each species. YDOT is the
   !             net rate of change in species concentrations resulting
   !             from chemical production minus chemical loss.
   !
   !  Preconditions: None
   !                                                                     
   !  Key Subroutines/Functions Called: None
   !
   !  Revision History: Prototype created by Jerry Gipson, August, 2004
   !                    Based on the SMVGEAR code originally developed by 
   !                    M. Jacobson, (Atm. Env., Vol 28, No 2, 1994).
   !                    31 Jan 05 J.Young: get BLKSIZE from dyn alloc horizontal
   !                    & vertical domain specifications module (GRID_CONF)
   !                    28 Jun 10 J.Young: remove unnecessary modules and includes
   !                    15 Jul 14 B.Hutzell: replaced mechanism include files with 
   !                    RXNS_DATA module, replaced call to CALC_SPECIAL with 
   !                    SPECIAL_RATES in RXNS_FUNCTION module and added intent
   !                    declarations to arguments
   !***********************************************************************

   !      USE RXNS_DATA
   !      USE RXNS_FUNCTION
   !      USE RBDATA               ! ROS3 solver data
         !USE CUDAFOR

         IMPLICIT NONE

   !..Includes:

   !..Arguments:
         INTEGER, VALUE :: NCSP          ! Index of mech to use: 1=gas/day, 2=gas/night
         REAL( 8 ) :: YIN( BLKSIZE,NUMB_MECH_SPC )  ! Species concs, ppm
         !REAL( 8 ) :: YDOT( BLKSIZE,NUMB_MECH_SPC )
         INTEGER, VALUE :: ISCHAN
         INTEGER, VALUE :: NUMCELLS
         INTEGER, VALUE :: NCS2
         INTEGER, VALUE :: NRXNS
         INTEGER, VALUE :: MXRCT
         INTEGER, VALUE :: MXPRD
         INTEGER, VALUE :: NCS
         INTEGER, VALUE :: BLKSIZE
         INTEGER, VALUE :: NUMB_MECH_SPC
         INTEGER, VALUE :: NSPECIAL_RXN
         !REAL( 8 ) :: BLKTEMP( NUMCELLS) , BLKDENS( NUMCELLS )

   !..Parameters: None

   !..External FUNCTIONS: None

   !..Local Variables:
         INTEGER :: ISP              ! Loop index for species
         INTEGER :: ISP1, ISP2, ISP3 ! Pointers to species numbers
         INTEGER :: NP               ! Loop index for number of products
         INTEGER :: NR               ! Loop index for number of reactants
         INTEGER :: NRK              ! Reaction number
         INTEGER :: NRX              ! Loop index for number of reactions
         REAL( 8 ) :: FRACN
         INTEGER :: IX, TX, STRIDE

   !***********************************************************************      

         IF ( NSPECIAL_RXN .GT. 0 ) CALL SPECIAL_RATES_D( NUMCELLS, YIN, BLKSIZE, NUMB_MECH_SPC )   ! calculate special rate coefficients

   !IF ( IX .EQ. 1 ) ! PRINT *, 'EXECUTING ....'
         !IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X
         !STRIDE = BLOCKDIM%X * GRIDDIM%X
         
   ! ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
   !  Initialize dc/dt
   ! ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

         DO ISP = 1, ISCHAN
            DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
               YDOT_D( IX,ISP ) = 0.0D0
            END DO
            !CALL SYNCTHREADS()
         END DO
         !CALL SYNCTHREADS()
   ! ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
   !  Loop over reactions to calculate dc/dt
   ! ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

         DO 100 NRX = 1, NUSERAT_D( NCSP )
         
            NRK = NKUSERAT_D( NRX,NCSP ) 
            !PRINT *, "NRK ", NRK

   !..Calculate reaction rate
            IF ( NREACT_D( NRK ) .EQ. 1 ) THEN
               ISP1 = IRM2_D( NRK, 1, NCS )
               DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
                  RXRAT_D( IX,NRK ) = RKI_D( IX,NRK ) &
                                    * YIN( IX,ISP1 )
               END DO
            ELSE IF ( NREACT_D( NRK ) .EQ. 2 ) THEN
               ISP1 = IRM2_D( NRK,1,NCS )
               ISP2 = IRM2_D( NRK,2,NCS )
               DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
                  RXRAT_D( IX,NRK ) = RKI_D( IX,NRK ) &
                                    * YIN( IX,ISP1 ) &
                                    * YIN( IX,ISP2 )
               END DO
            ELSE IF ( NREACT_D( NRK ) .EQ. 3 ) THEN
               ISP1 = IRM2_D( NRK,1,NCS )
               ISP2 = IRM2_D( NRK,2,NCS )
               ISP3 = IRM2_D( NRK,3,NCS )
               DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
                  RXRAT_D( IX,NRK ) = RKI_D( IX,NRK ) &
                                    * YIN( IX,ISP1 ) &
                                    * YIN( IX,ISP2 ) &
                                    * YIN( IX,ISP3 )
               END DO 
            ELSE IF ( NREACT_D( NRK ) .EQ. 0 ) THEN
               DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
                  RXRAT_D( IX,NRK ) = RKI_D( IX,NRK )
               END DO
            END IF
            !CALL SYNCTHREADS()
   !..Subtract loss terms from dc/dt for this reaction 
            DO NR = 1, NREACT_D( NRK )
               ISP1 = IRM2_D( NRK,NR,NCS )
               DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
                  YDOT_D( IX,ISP1 ) = YDOT_D( IX,ISP1 ) &
                                    - RXRAT_D( IX,NRK )
               END DO
               !CALL SYNCTHREADS()
            END DO
            !CALL SYNCTHREADS()
            !IF ( BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X .EQ. 1 ) PRINT *, 'YDOT ', MAXVAL( YDOT_D )
   !..Add production terms to dc/dt for this reaction
            DO NP = 1, NPRDCT_D( NRK )
               ISP1 = IRM2_D( NRK,NP+3,NCS )
               DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
                  YDOT_D( IX,ISP1 ) = YDOT_D( IX,ISP1 ) &
                                    + SC_D( NRK,NP ) * RXRAT_D( IX,NRK )
               END DO
               !CALL SYNCTHREADS()
            END DO
            !IF ( BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X .EQ. 1 ) PRINT *, 'YDOT ', MAXVAL( YDOT_D )
            !CALL SYNCTHREADS()
   100   CONTINUE               ! END LOOP OVER REACTIONS
         !IF ( IX .EQ. 1 ) ! PRINT *, 'RETURNING RBFEVAL....'
         ! PRINT *, 'RETURNING RBFEVAL....'
         !CALL SYNCTHREADS()
         RETURN
      END

   ATTRIBUTES( DEVICE ) SUBROUTINE RBJACOB( NCSP, YIN, &
                                             ISCHAN, NUMCELLS, &
                                             NCS2, NRXNS, &
                                             MXRR, MXRP, MXRCT, MXPRD, &
                                             BLKSIZE, NCS, NUMB_MECH_SPC )

   !***********************************************************************
   !
   !  Function: Compute the Jacobian matrix, [J] ( Jij = d[dCi/dt]/dCj )
   !
   !  Preconditions: None
   !
   !  Key Subroutines/Functions Called: None
   !
   !  Revision History: Prototype created by Jerry Gipson, August, 2004
   !                    Based on the SMVGEAR code originally developed by 
   !                    M. Jacobson, (Atm. Env., Vol 28, No 2, 1994).
   !
   !                    31 Jan 05 J.Young: get BLKSIZE from dyn alloc horizontal
   !                    & vertical domain specifications module (GRID_CONF)
   !                    28 Jun 10 J.Young: remove unneccesary modules and include files
   !                    22 Aug 11 J.Young: fixed bug: initialize CC2( IX,0 )
   !                    15 Jul 14 B.Hutzell: replaced mechanism include files with 
   !                    RXNS_DATA module and added intent declarations to arguments
   !
   !***********************************************************************

   !      USE RXNS_DATA
   !      USE RBDATA                ! ROS3 solver data
         !USE CUDAFOR

         IMPLICIT NONE

   !..Includes:

   !..Arguments:
         INTEGER, VALUE :: NCSP         ! Index of chem mech to use; 1=gas/day, 2=gas/night
         REAL( 8 ) :: YIN( BLKSIZE,NUMB_MECH_SPC )    ! Species concs, ppm
         INTEGER, VALUE :: NCS2
         INTEGER, VALUE :: NRXNS
         INTEGER, VALUE :: MXRR
         INTEGER, VALUE :: MXRP
         INTEGER, VALUE :: ISCHAN
         INTEGER, VALUE :: NUMCELLS
         INTEGER, VALUE :: MXRCT
         INTEGER, VALUE :: MXPRD
         INTEGER, VALUE :: BLKSIZE
         INTEGER, VALUE :: NCS
         INTEGER, VALUE :: NUMB_MECH_SPC
         INTEGER, VALUE :: MXARRAY
         INTEGER :: IX                              ! Device thread index

   !..Parameters: None

   !..External Functions: None

   !..Local Variables:
         INTEGER :: IALP           ! Pointer to location of PD term in EXPLIC
         INTEGER :: IAR            ! Loop index for non-zero entries in [P]
         INTEGER :: IARP           ! Pointer to location of PD term in [P]
         INTEGER :: IARRY          ! Pointer to end of [P] entries
         INTEGER :: ISCP           ! Pointer to stoichiometric coefficient
         INTEGER :: ISPC           ! Loop index for species
         INTEGER :: JR1, JR2, JR3  ! Pointer to reactant species conc.
         INTEGER :: NL             ! Loop index for loss PD terms
         INTEGER :: NLD            ! Number of loss PD terms for each rxn.
         INTEGER :: NP             ! Loop index for prod PD terms
         INTEGER :: NPD            ! Number of prod PD terms for each rxn.
         INTEGER :: NRK            ! Reaction number
         INTEGER :: NRX            ! Loop index for number of reactions
         INTEGER :: NONDIAG        ! Pointer to end of off-diagonal entries
         INTEGER :: NONDIAG1       ! Pointer to start of diagonal entries

         INTEGER TX, STRIDE
         
         REAL( 8 ) :: CR2                   ! Temporary product for 3 reactant rxns
         REAL( 8 ) :: FRACN                 ! Stoichiometric coeff. times b*h
         !REAL( 8 ) :: EXPLIC( BLKSIZE,3 )   ! Reaction partial derivative terms

   !***********************************************************************
   !IF ( IX .EQ. 1 ) ! PRINT *, 'EXECUTING ....'
         !IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X
         !STRIDE = BLOCKDIM%X * GRIDDIM%X
   ! ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
   !  Zero out Jacobian ( stored in sparse matrix array cc2 )
   ! ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
         IARRY = IARRAY_D( NCSP ) 
         NONDIAG = IARRY - ISCHAN  
         NONDIAG1 = NONDIAG + 1
   !     DO IAR = 1, NONDIAG
         DO IAR = 0, NONDIAG
            DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
               CC2_D( IX,IAR ) = 0.0D0
            END DO
            !CALL SYNCTHREADS()
         END DO
         !CALL SYNCTHREADS()
         DO IAR = NONDIAG1, IARRY
            DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
               CC2_D( IX,IAR ) = 0.0D0
            END DO
            !CALL SYNCTHREADS()
         END DO

         !CALL SYNCTHREADS()

   ! ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
   !  Loop over reaction rates adding partial derivative terms; EXPLIC
   !  holds the PD terms according to number of reactants
   ! ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
         DO 240 NRX = 1, NUSERAT_D( NCSP )

            NRK = NKUSERAT_D( NRX,NCSP )
            
   !...partial derivative term for reactions with 1 reactant
            IF ( NREACT_D( NRK ) .EQ. 1 ) THEN
               DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
                  EXPLIC( IX,1 ) = RKI_D( IX,NRK ) 
                  !IF ( IX .EQ. 1 ) PRINT *, 'NREACT = 1', EXPLIC( IX,1 )
               END DO

   !...partial derivative terms for reactions with 2 reactants
            ELSE IF ( NREACT_D( NRK ) .EQ. 2 ) THEN
               JR1 = IRM2_D( NRK,1,NCS )
               JR2 = IRM2_D( NRK,2,NCS )
               DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
                  EXPLIC( IX,1 )  = RKI_D( IX,NRK ) &
                                    * YIN( IX,JR2 )
                  EXPLIC( IX,2 )  = RKI_D( IX,NRK ) &
                                    * YIN( IX,JR1 )
                  !IF ( IX .EQ. 1 ) PRINT *, 'NREACT = 2', EXPLIC( IX,1 ), EXPLIC( IX,2 )
               END DO

   !.....partial derivative terms for reactions with 3 reactants
            ELSE IF ( NREACT_D( NRK ) .EQ. 3 ) THEN
               JR1 = IRM2_D( NRK,1,NCS )
               JR2 = IRM2_D( NRK,2,NCS )
               JR3 = IRM2_D( NRK,3,NCS )
               DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
                  CR2 = RKI_D( IX,NRK ) * YIN( IX,JR2 )
                  EXPLIC( IX,1 ) = CR2 * YIN( IX,JR3 )
                  !EXPLIC( IX,1 ) = RKI_D( IX,NRK ) &
                  !                  * YIN( IX,JR2 ) &
                  !                  * YIN( IX,JR3 )
                  EXPLIC( IX,2 ) = RKI_D( IX,NRK ) &
                                    * YIN( IX,JR1 ) &
                                    * YIN( IX,JR3 ) 
                  EXPLIC( IX,3 ) = CR2 * YIN( IX,JR1 )
                  !EXPLIC( IX,3 ) = RKI_D( IX,NRK ) &
                  !                  * YIN( IX,JR1 ) &
                  !                  * YIN( IX,JR2 )
                  !IF ( IX .EQ. 1 ) PRINT *, 'NREACT = 3', EXPLIC( IX,1 ), EXPLIC( IX,2 ), EXPLIC( IX,3 )
               END DO
            END IF

            !CALL SYNCTHREADS()
   ! ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
   !  Add PD terms to [J] for this reaction
   ! ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
   !...loss terms
            NLD = NDERIVL_D( NRK,NCSP )         
            DO NL = 1, NLD
               IARP = JARRL_D( NRK,NL,NCSP )
               IALP = JLIAL_D( NRK,NL,NCSP )
               DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
                  CC2_D( IX,IARP ) = CC2_D( IX,IARP ) - EXPLIC( IX,IALP ) 
               END DO
               !CALL SYNCTHREADS()
            END DO    ! End loop over loss terms
            !CALL SYNCTHREADS()
   !...production terms with stoichiomteric coeff EQ 1.0 and NE 1.0
            NPD = NDERIVP_D( NRK,NCSP )
            DO 220 NP = 1, NPD

               IARP = JARRP_D( NRK,NP,NCSP )
               IALP = JPIAL_D( NRK,NP,NCSP )

               IF ( ICOEFF_D( NRK,NP,NCSP ) .EQ. 0 ) THEN
   !..production terms with unit stoichiometry
                  DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
                     CC2_D( IX,IARP ) = CC2_D( IX,IARP ) + EXPLIC( IX,IALP ) 
                  END DO
               ELSE
   !..production terms with non-unit stoichiometry
                  ISCP = ICOEFF_D( NRK,NP,NCSP )
                  FRACN = SC_D( NRK,ISCP )
                  !IF ( IX .EQ. 1 ) PRINT *, 'SC_D ', SC_D( NRK,ISCP ), 'FRACN ', FRACN
                  DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
                     CC2_D( IX,IARP ) = CC2_D( IX,IARP ) + FRACN &
                                       * EXPLIC( IX,IALP )
                  END DO
               END IF
               !CALL SYNCTHREADS()
   220      END DO !CONTINUE      ! End loop over production terms
            !CALL SYNCTHREADS()
   240   END DO !CONTINUE      ! End loop over reactions
         !CALL SYNCTHREADS()

         RETURN 
      END

   ATTRIBUTES( DEVICE ) SUBROUTINE RBDECOMP( NCSP, ISCHAN, &
                                             NUMCELLS, NCS2, NUMB_MECH_SPC, &
                                             MXCOUNT2, MXARRAY )

   !!***********************************************************************
   !!
   !!  Function:  Decompose the matrix [A] into lower- and upper-
   !!             triangular form to facilitate solution of the set of 
   !!             linear simultaneous equations of the form [A]{x}={b}.
   !!
   !!  Preconditions: None
   !!                                                                     
   !!  Key Subroutines/Functions Called: None
   !!
   !!  Revision History: Prototype created by Jerry Gipson, August, 2004.
   !!                      Based on the SMVGEAR code originally developed by 
   !!                      M. Jacobson, (Atm. Env., Vol 28, No 2, 1994).
   !!
   !!  14 Jul 14 B.Hutzell: added intent declaration to arguments
   !!***********************************************************************

   !      USE RBDATA              ! ROS3 solver data
         !USE CUDAFOR

         IMPLICIT NONE
         
   !!..Includes:
         INTEGER, VALUE :: NCSP  ! Index of chem mech to use
                                       ! 1=gas/day, 2=gas/night

   !!..Arguments:
         INTEGER, VALUE :: NCS2
         INTEGER, VALUE :: ISCHAN
         INTEGER, VALUE :: NUMB_MECH_SPC
         INTEGER, VALUE :: MXCOUNT2
         INTEGER, VALUE :: NUMCELLS
         INTEGER, VALUE :: MXARRAY
         INTEGER, VALUE :: BLKSIZE
         INTEGER :: IX

   !!..Parameters: None

   !!..External Functions: None

   !!..Local Variables:
         INTEGER :: IAR             ! Pointer to diagonal terms
         INTEGER :: IC              ! Loop index for ops in decomp loop 1
         INTEGER :: IDLO            ! Start index for decomp loop 1
         INTEGER :: IDHI            ! End index for decomp loop 1
         INTEGER :: IJ0             ! Pointer to ij term 1 in decomp loop 1
         INTEGER :: IJ1             ! Pointer to ij term 2 in decomp loop 1
         INTEGER :: IJA             ! Pointer to ij term 1 in decomp loop 2
         INTEGER :: IJB             ! Pointer to ij term 2 in decomp loop 2
         INTEGER :: IK0             ! Pointer to ik term 1 in decomp loop 1
         INTEGER :: IK1             ! Pointer to ik term 2 in decomp loop 1
         INTEGER :: J               ! Loop index for number of species
         INTEGER :: JC              ! Loop index for ops in decomp loop 2
         INTEGER :: JHI1            ! End index for 2-term decomp loop 2
         INTEGER :: JHI2            ! End index for 1-term decomp loop 2
         INTEGER :: JLO1            ! Start index for 2-term decomp loop 2
         INTEGER :: JLO2            ! Start index for 1-term decomp loop 2
         INTEGER :: KJ0             ! Pointer to kj term 1 in decomp loop 1
         INTEGER :: KJ1             ! Pointer to kj term 2 in decomp loop 1

         INTEGER TX, STRIDE
      
   !!***********************************************************************      
   !IF ( IX .EQ. 1 ) ! PRINT *, 'EXECUTING ....'
         !IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X
         !STRIDE = BLOCKDIM%X * GRIDDIM%X
   !! ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
   !!  First loop of L-U decomposition 
   !! ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
         JHI2 = JZLO_D( NCSP )
         DO 100 J = 1, ISCHAN
            IDLO = IDEC1LO_D( J,NCSP )
            IDHI = IDEC1HI_D( J,NCSP )
            DO IC = IDLO, IDHI
               IJ0 = IJDECA_D( IC )
               IJ1 = IJDECB_D( IC )
               IK0 = IKDECA_D( IC )
               IK1 = IKDECB_D( IC )
               KJ0 = KJDECA_D( IC )
               KJ1 = KJDECB_D( IC )
               !CALL SYNCTHREADS()
               DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
                  CC2_D( IX,IJ0 ) = CC2_D( IX,IJ0 ) &
                                 - CC2_D( IX,IK0 ) * CC2_D( IX,KJ0 )
                  CC2_D( IX,IJ1 ) = CC2_D( IX,IJ1 ) &
                                 - CC2_D( IX,IK1 ) * CC2_D( IX,KJ1 )
               END DO
               !CALL SYNCTHREADS()
            END DO
            !CALL SYNCTHREADS()
   !...vdiag = 1 / current diagonal term of the decomposed matrix
            IAR = JARRAYPT_D( J, J, NCSP )
            DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
               VDIAG_D( IX,J )  = 1.0D0 / CC2_D( IX,IAR )
            END DO
            !CALL SYNCTHREADS()
   !! ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
   !!  Second loop of decompostion. The elements of L are divided by the
   !!  diagonal element, and the process is divided into parts to improve
   !!  vectorization.
   !! ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
            JLO1 = JHI2 + 1
            JHI1 = JHI2 + JHIZ1_D( J, NCSP ) 
            JLO2 = JHI1 + 1 
            JHI2 = JHI1 + JHIZ2_D( J, NCSP )
            
   !!...do 2 terms at a time
            DO JC = JLO1, JHI1
               IJA = JZEROA_D( JC )
               IJB = JZEROB_D( JC )
               DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
                  CC2_D( IX,IJA ) = CC2_D( IX,IJA ) * VDIAG_D( IX,J )  
                  CC2_D( IX,IJB ) = CC2_D( IX,IJB ) * VDIAG_D( IX,J )  
               END DO
               !CALL SYNCTHREADS()
            END DO
            !CALL SYNCTHREADS()
   !!...do 1 term at a time 
            DO JC = JLO2, JHI2 
               IJA = JZEROA_D( JC )
               DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
                  CC2_D( IX,IJA ) = CC2_D( IX,IJA ) * VDIAG_D( IX,J )
               END DO
               !CALL SYNCTHREADS()
            END DO
            !CALL SYNCTHREADS()
   100   END DO !CONTINUE
         !IF ( IX .EQ. 1 ) ! PRINT *, 'RETURNING RBDECOMP....'
         !CALL SYNCTHREADS()
         RETURN
      END

   ATTRIBUTES( DEVICE ) SUBROUTINE RBSOLVE( NCSP, RHS, ISCHAN, &
                                             NUMCELLS, BLKSIZE, N_SPEC, &
                                             NCS2, MXARRAY, NUMB_MECH_SPC )

   !**********************************************************************
   !
   !  Function:  Solve the set of linear simultaneous equations of the
   !             form [A]{x}={b} using the decomposed lower and upper
   !             triangular matrices [L] and [U]. The subroutine first 
   !             solves for {!} in [L]{!}={b}, and then for {x} in
   !             [U]{x}={!}.
   !
   !  Preconditions: Subroutine DECOMP must have been called
   !                                                                     
   !  Key Subroutines/Functions Called: None
   !
   !  Revision History: Prototype created by Jerry Gipson, August, 2004.
   !                    Based on the SMVGEAR code originally developed by 
   !                    M. Jacobson, (Atm. Env., Vol 28, No 2, 1994)
   !
   !                    31 Jan 05 J.Young: get BLKSIZE from dyn alloc horizontal
   !                    & vertical domain specifications module (GRID_CONF)
   !                    28 Jun 10 J.Young: remove unnecessary modules and include files
   !                    14 Jul 14 B.Hutzell: added intent declaration to arguments
   !***********************************************************************

   !      USE RBDATA                       ! ROS3 solver data
         !USE CUDAFOR

         IMPLICIT NONE
         
   !..Includes: None
         
   !..Arguments:
         INTEGER, VALUE ::  NCSP        ! Index of chem mech to use: 1=gas/day, 2=gas/night
         REAL( 8 ) ::  RHS( BLKSIZE,N_SPEC )  ! Right hand side = {b}
         INTEGER, VALUE :: ISCHAN
         INTEGER, VALUE :: NCS2
         INTEGER, VALUE :: MXARRAY
         INTEGER, VALUE :: NUMCELLS
         INTEGER, VALUE :: BLKSIZE
         INTEGER, VALUE :: N_SPEC
         INTEGER, VALUE :: NUMB_MECH_SPC
         INTEGER :: IX

   !..Parameters: None

   !..External Functions: None

   !..Local Variables:
         INTEGER :: I                        ! Loop index for number of species
         INTEGER :: IJ                       ! Counter of # of terms summed
         INTEGER :: IJ0, IJ1, IJ2,  &        ! Pointers to location of ij entries in
               IJ3, IJ4                    ! decomposed matrix
         INTEGER :: J, J1, J2, J3, J4        ! Pointers to species # for dc/dt
         INTEGER :: JZ                       ! Loop index inner backsub loops

         INTEGER TX, STRIDE

   !***********************************************************************
   !IF ( IX .EQ. 1 ) ! PRINT *, 'EXECUTING ....'
         !IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X
         !STRIDE = BLOCKDIM%X * GRIDDIM%X
   ! ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
   !  Back-substition loop 1
   ! ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
         IJ = 1 
         DO 60 I = 1, ISCHAN
         
   !.....sum 5 terms at a time
            DO JZ = 1, KZHI0_D( I, NCSP ), 5     
               IJ0 = IJ 
               IJ1 = IJ + 1
               IJ2 = IJ + 2 
               IJ3 = IJ + 3 
               IJ4 = IJ + 4 
               J   = KZERO_D( IJ0,NCSP )
               J1  = KZERO_D( IJ1,NCSP )
               J2  = KZERO_D( IJ2,NCSP )
               J3  = KZERO_D( IJ3,NCSP )
               J4  = KZERO_D( IJ4,NCSP )
               !CALL SYNCTHREADS()
               IJ = IJ + 5
               DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
                  RHS( IX,I ) = RHS( IX,I ) &
                                 - CC2_D( IX,IJ0 ) * RHS( IX, J ) &
                                 - CC2_D( IX,IJ1 ) * RHS( IX,J1 ) &
                                 - CC2_D( IX,IJ2 ) * RHS( IX,J2 ) &
                                 - CC2_D( IX,IJ3 ) * RHS( IX,J3 ) &
                                 - CC2_D( IX,IJ4 ) * RHS( IX,J4 )
               END DO
               !CALL SYNCTHREADS()
            END DO
            !CALL SYNCTHREADS()
   !.....sum 2 terms at a time
            DO JZ = KZLO1_D( I,NCSP ), KZHI1_D( I,NCSP ), 2    
               IJ0 = IJ 
               IJ1 = IJ + 1
               J   = KZERO_D( IJ0,NCSP )
               J1  = KZERO_D( IJ1,NCSP )
               !CALL SYNCTHREADS()
               IJ = IJ + 2
               DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
                  RHS( IX,I ) = RHS( IX,I ) &
                                 - CC2_D( IX,IJ0 ) * RHS( IX, J ) &
                                 - CC2_D( IX,IJ1 ) * RHS( IX,J1 )
               END DO
               !CALL SYNCTHREADS()
            END DO
            !CALL SYNCTHREADS()
   !.....sum 1 term at a time
            DO JZ = KZLO2_D( I,NCSP ), KZILCH_D( I,NCSP )    
               IJ0 = IJ
               J   = KZERO_D( IJ0,NCSP )
               !CALL SYNCTHREADS()
               IJ = IJ + 1
               DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
                  RHS( IX,I ) = RHS( IX,I ) &
                                 - CC2_D( IX,IJ0 ) * RHS( IX,J )
               END DO
               !CALL SYNCTHREADS()
            END DO
            !CALL SYNCTHREADS()
   60    CONTINUE
   
   ! ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
   !  Back-substitution loop 2
   ! ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
         DO 180 I = ISCHAN, 1, -1

   !...sum 5 terms at a time
            DO JZ = 1, MZHI0_D( I,NCSP ), 5   
               IJ0 = IJ
               IJ1 = IJ + 1
               IJ2 = IJ + 2 
               IJ3 = IJ + 3 
               IJ4 = IJ + 4 
               J   = KZERO_D( IJ0,NCSP )
               J1  = KZERO_D( IJ1,NCSP )
               J2  = KZERO_D( IJ2,NCSP )
               J3  = KZERO_D( IJ3,NCSP )
               J4  = KZERO_D( IJ4,NCSP )
               !CALL SYNCTHREADS()
               IJ = IJ + 5
               DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
                  RHS( IX,I ) = RHS( IX,I ) &
                                 - CC2_D( IX,IJ0 ) * RHS( IX, J ) &
                                 - CC2_D( IX,IJ1 ) * RHS( IX,J1 ) &
                                 - CC2_D( IX,IJ2 ) * RHS( IX,J2 ) &
                                 - CC2_D( IX,IJ3 ) * RHS( IX,J3 ) &
                                 - CC2_D( IX,IJ4 ) * RHS( IX,J4 )
               END DO
               !CALL SYNCTHREADS()
            END DO
            !CALL SYNCTHREADS()
   !...sum 2 terms at a time 
            DO JZ = MZLO1_D( I,NCSP ), MZHI1_D( I,NCSP ), 2 
               IJ0 = IJ 
               IJ1 = IJ + 1
               J   = KZERO_D( IJ0,NCSP )
               J1  = KZERO_D( IJ1,NCSP )
               !CALL SYNCTHREADS()
               IJ = IJ + 2
               DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
                  RHS( IX,I ) = RHS( IX,I ) &
                                 - CC2_D( IX,IJ0 ) * RHS( IX, J )  &
                                 - CC2_D( IX,IJ1 ) * RHS( IX,J1 ) 
               END DO
               !CALL SYNCTHREADS()
            END DO
            !CALL SYNCTHREADS()
   !...sum 1 term at a time
            DO JZ = MZLO2_D( I,NCSP ), MZILCH_D( I,NCSP ) 
               IJ0 = IJ 
               J   = KZERO_D( IJ0,NCSP )
               !CALL SYNCTHREADS()
               IJ = IJ + 1 
               DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
                  RHS( IX,I ) = RHS( IX,I ) &
                                 - CC2_D( IX,IJ0 ) * RHS( IX,J ) 
               END DO
               !CALL SYNCTHREADS()
            END DO
            !CALL SYNCTHREADS()
   !...adjust diagonal element
            DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
               RHS( IX,I ) = RHS( IX,I ) * VDIAG_D( IX,I )
            END DO
            !CALL SYNCTHREADS()
   180   CONTINUE
         !CALL SYNCTHREADS()
         RETURN
         END

   ATTRIBUTES( DEVICE ) SUBROUTINE SPECIAL_RATES_D( NUMCELLS, YIN, BLKSIZE, NUMB_MECH_SPC )
! Purpose: calculate special rate operators and update
!         appropriate rate constants

!       USE RXNS_DATA
       IMPLICIT NONE

! Arguments:
       INTEGER,      INTENT( IN  )   :: NUMCELLS        ! Number of cells in block 
       REAL( 8 ),    INTENT( IN )    :: YIN( BLKSIZE,NUMB_MECH_SPC )       ! species concs
       !REAL( 8 ),    INTENT( IN )    :: TEMP( BLKSIZE )       ! air temperature, K 
       !REAL( 8 ),    INTENT( IN )    :: DENS( BLKSIZE )       ! air density, Kg/m3
       !REAL( 8 ),    INTENT( INOUT ) :: RKI( :, : )     ! reaction rate constant, ppm/min 
       INTEGER BLKSIZE, NUMB_MECH_SPC
! Local:
       REAL( 8 ), PARAMETER :: DENSITY_TO_NUMBER = 2.07930D+19 ! Kg/m3 to molecules/cm3

       INTEGER   :: IX
       REAL( 8 ) :: INV_TEMP
       REAL( 8 ) :: CAIR
       REAL( 8 ) :: CFACT         ! scales operator if not multiplied by RKI, cm^3/(molecule) to 1/(ppm)
       REAL( 8 ) :: CFACT_SQU     ! scales operator if not multiplied by RKI, cm^6/(molec^2) to 1/(ppm^2)
! special rate operators listed below

       !IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X


       DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
          INV_TEMP  = 1.0D0 / BLKTEMP_D( IX )
          CAIR      = DENSITY_TO_NUMBER * BLKDENS_D( IX )
          CFACT     = 1.0D-06 * CAIR
          CFACT_SQU = 1.0D-12 * CAIR * CAIR


! define special rate operators


! define rate constants in terms of special rate operators 

       END DO

       RETURN
       END SUBROUTINE SPECIAL_RATES_D

ATTRIBUTES( GLOBAL ) SUBROUTINE RBKERNEL( CHEMSTEP, NCSP, LORDERING, ISCHAN,   &
                                          IDIAGBEG, DTSTART, OFFSET,   &
                                          BLKSIZE, NUMCELLS, N_SPEC, C21, C31, &
                                          C32, B1, B2, B3, D1, D2, D3, UROUND, &
                                          GROW, CONMIN, FACMIN, FACMAX, &
                                          FACONE, DTMAX, DTMIN, MXCELLS, NCS2,  &
                                          NUMB_MECH_SPC, RNSPEC, RGAM, &
                                          NRXNS, MXRCT, MXPRD, MXRR, MXRP, &
                                          MXCOUNT2, MXARRAY, NCS, &
                                          NSPECIAL_RXN )

    !USE RBROUTINES
    !USE CUDAFOR

   IMPLICIT NONE

!   Arguments
   REAL( 8 ), VALUE :: CHEMSTEP
   INTEGER, VALUE :: NCS
   INTEGER, VALUE :: NCSP
   LOGICAL, VALUE :: LORDERING
   INTEGER, VALUE :: ISCHAN
   INTEGER , VALUE:: IDIAGBEG
   INTEGER, VALUE :: OFFSET
   REAL( 8 ), VALUE :: RGAM
   INTEGER, VALUE :: BLKSIZE
   INTEGER, VALUE :: NUMCELLS
   INTEGER, VALUE :: N_SPEC
   REAL( 8 ), VALUE :: C21
   REAL( 8 ), VALUE :: C31
   REAL( 8 ), VALUE :: C32
   REAL( 8 ), VALUE :: B1
   REAL( 8 ), VALUE :: B2
   REAL( 8 ), VALUE :: B3
   REAL( 8 ), VALUE :: D1
   REAL( 8 ), VALUE :: D2
   REAL( 8 ), VALUE :: D3
   REAL( 8 ), VALUE :: UROUND
   REAL( 8 ), VALUE :: GROW
   REAL( 8 ), VALUE :: CONMIN
   REAL( 8 ), VALUE :: FACMIN
   REAL( 8 ), VALUE :: FACMAX
   REAL( 8 ), VALUE :: FACONE
   REAL( 8 ), VALUE :: DTMAX
   REAL( 8 ), VALUE :: DTMIN
   REAL( 8 ), VALUE :: DTSTART
   INTEGER, VALUE :: MXCELLS
   INTEGER, VALUE :: NCS2
   INTEGER, VALUE :: NUMB_MECH_SPC
   REAL( 8 ), VALUE :: RNSPEC
   INTEGER, VALUE :: NRXNS
   INTEGER, VALUE :: MXRCT
   INTEGER, VALUE :: MXPRD
   INTEGER, VALUE :: MXRR
   INTEGER, VALUE :: MXRP
   INTEGER, VALUE :: MXCOUNT2
   INTEGER, VALUE :: MXARRAY
   INTEGER, VALUE :: NSPECIAL_RXN
   !REAL( 8 ) :: BLKTEMP( NUMCELLS ), BLKDENS( NUMCELLS )
!   Local variables
   REAL( 8 ) :: DT
   REAL( 8 ) :: TNOW
   LOGICAL :: LPASS
   INTEGER JSPC
   REAL( 8 ) YLOWEPS
   REAL( 8 ) ERRYMAX
   REAL( 8 ) TEND
   REAL( 8 ) DTINV
   REAL( 8 ) GDTINV
   INTEGER J
   INTEGER N
   REAL( 8 ) X21, X31, X32
   REAL( 8 ) YTOL
   REAL( 8 ) MAXERR
   REAL( 8 ) DTFAC
   !REAL( 8 ) DTOLD, DTNEW !, TOLD, TNEW
   !LOGICAL LPASS_LOC
   INTEGER IX, TX, STRIDE, IDX, ISTAT

   !IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X
   !STRIDE = BLOCKDIM%X * GRIDDIM%X

   !DO IDX = 1, BLOCKDIM%X * GRIDDIM%X
   !   IF ( TX .EQ. IDX ) PRINT *, TX
   !END DO

   !IF ( TX .EQ. 1 ) PRINT *, 'DEVICE', 'RKI', MAXVAL( RKI_D( 1:NUMCELLS,: ) ), 'SC', MAXVAL( SC_D )

   !LPASS_LOC = LPASS

   DT = MAX( DTMIN, DTSTART )
   TNOW = 0.0D0
   LPASS = .FALSE.

    DO 100 WHILE ( TNOW .LT. CHEMSTEP )

         !IF ( IX .EQ. 1 ) PRINT *, "LOOPING"

         !CALL SYNCTHREADS()

         CALL RBFEVAL( NCSP, Y_D,  &
                        NUMCELLS, NCS2, &
                        NRXNS, MXRCT, MXPRD, &
                        ISCHAN, NCS, BLKSIZE, &
                        NUMB_MECH_SPC, &
                        NSPECIAL_RXN )
         
         IF ( LORDERING ) THEN

            DO JSPC = 1, ISCHAN  
               YLOWEPS = ATOL_D( JSPC ) / ( MIN( RTOL_D( JSPC ), 0.003D+00 ) )
               DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
                  ERRYMAX = YDOT_D( IX,JSPC ) &
                          / ( Y_D( IX,JSPC ) + YLOWEPS )
                  ERRMX2_D( OFFSET + IX ) = ERRMX2_D( OFFSET + IX ) &
                                          + ERRYMAX * ERRYMAX
               END DO
               !CALL SYNCTHREADS()
            END DO
            !CALL SYNCTHREADS()
            RETURN
   
         END IF

         TEND = TNOW + DT 

         IF ( TEND .GT. CHEMSTEP ) THEN
            DT = CHEMSTEP - TNOW
            TEND = CHEMSTEP
         END IF    

         DTINV = 1.0D+00 / DT

         GDTINV = DTINV * RGAM
      
         !CALL SYNCTHREADS()
         CALL RBJACOB( NCSP, Y_D, &
                        ISCHAN, NUMCELLS, &
                        NCS2, NRXNS, &
                        MXRR, MXRP, MXRCT, MXPRD, &
                        BLKSIZE, NCS, NUMB_MECH_SPC )
         

         DO J = IDIAGBEG, IARRAY_D( NCSP )
            DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
               CC2_D( IX,J ) = CC2_D( IX,J ) - GDTINV
            END DO
            !CALL SYNCTHREADS()
         END DO

         !CALL SYNCTHREADS()
         CALL RBDECOMP( NCSP, ISCHAN, &
                        NUMCELLS, NCS2, NUMB_MECH_SPC, &
                        MXCOUNT2, MXARRAY )
         
!   STAGE 1

         DO N = 1, N_SPEC
            DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
               K1_D( IX,N ) = -YDOT_D( IX,N )
            END DO
            !CALL SYNCTHREADS()
         END DO      

         !CALL SYNCTHREADS()
         CALL RBSOLVE( NCSP, K1_D, ISCHAN, &
                        NUMCELLS, BLKSIZE, N_SPEC, &
                        NCS2, MXARRAY, NUMB_MECH_SPC )

!   STAGE 2

         DO N = 1, N_SPEC
            DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
               YP_D( IX,N ) = Y_D( IX,N ) + K1_D( IX,N )
            END DO
            !CALL SYNCTHREADS()
         END DO      

         !CALL SYNCTHREADS()
         CALL RBFEVAL( NCSP, YP_D,  &
                        NUMCELLS, NCS2, &
                        NRXNS, MXRCT, MXPRD, &
                        ISCHAN, NCS, BLKSIZE, &
                        NUMB_MECH_SPC, &
                        NSPECIAL_RXN )
         
         X21 = C21 * DTINV
         DO N = 1, N_SPEC
            DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
               K2_D( IX,N ) = -YDOT_D( IX,N ) - X21 * K1_D( IX,N )
            END DO
            !CALL SYNCTHREADS()
         END DO      

         !CALL SYNCTHREADS()
         CALL RBSOLVE( NCSP, K2_D, ISCHAN, &
                        NUMCELLS, BLKSIZE, N_SPEC, &
                        NCS2, MXARRAY, NUMB_MECH_SPC )
         
!   STAGE 3

         X31 = C31 * DTINV
         X32 = C32 * DTINV
         DO N = 1, N_SPEC
            DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
               K3_D( IX,N ) = -YDOT_D( IX,N ) - X31 * K1_D( IX,N ) - X32 * K2_D( IX,N )
            END DO
            !CALL SYNCTHREADS()
         END DO

         !CALL SYNCTHREADS()
         CALL RBSOLVE( NCSP, K3_D, ISCHAN, &
                        NUMCELLS, BLKSIZE, N_SPEC, &
                        NCS2, MXARRAY, NUMB_MECH_SPC )
         
!   FINAL SOLUTION

         DO N = 1, N_SPEC
            DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
               YP_D( IX,N ) = Y_D( IX,N ) + B1 * K1_D( IX,N ) &
                            + B2 * K2_D( IX,N ) + B3 * K3_D( IX,N )
            END DO
            !CALL SYNCTHREADS()
         END DO

!   ESTIMATE ERROR

         DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
            ERR( IX ) = 0.0D+00
         END DO
         !ERR = 0.0D+00
         !CALL SYNCTHREADS()
         DO N = 1, N_SPEC
            DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
               YTOL = ATOL_D( N ) + RTOL_D( N ) * ABS( YP_D( IX,N ) )
               ERR( IX ) = ERR( IX ) &
                            + ( ( D1 * K1_D( IX,N ) + D2 * K2_D( IX,N ) &
                            + D3 * K3_D( IX,N ) ) / YTOL ) ** 2
           END DO
           !CALL SYNCTHREADS()
         END DO

         !IF ( IX .LE. NUMCELLS ) ERR( IX ) = SQRT( ERR( IX ) * RNSPEC )
         DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
            ERR( IX ) = SQRT( ERR( IX ) * RNSPEC )
         END DO

         !IF ( IX .EQ. 1 ) PRINT *, 'RNSPEC ', RNSPEC

         MAXERR = MAX( UROUND, MAXVAL( ERR ) )

         DTFAC = 0.9D+00 / MAXERR ** GROW

        !IF ( IX .EQ. 1 ) PRINT *, 'MAXERR ', MAXERR

        IF ( MAXERR .LE. 1.0D+00 ) THEN

            !IF ( IX .EQ. 1 ) PRINT *, 'MIN YP', MINVAL( YP_D( 1:NUMCELLS,: ) )

            DO N = 1, NUMB_MECH_SPC
               DO IX = BLOCKDIM%X * ( BLOCKIDX%X - 1 ) + THREADIDX%X, NUMCELLS, BLOCKDIM%X * GRIDDIM%X
                  Y_D( IX,N ) = MAX( YP_D( IX,N ), CONMIN )
               END DO
               !CALL SYNCTHREADS()
            END DO

            !IF ( IX .EQ. 1 ) PRINT *, 'MIN Y', MINVAL( Y_D( 1:NUMCELLS,: ) )

            TNOW = TEND
            
            IF ( LPASS ) THEN
               DTFAC = MAX( FACMIN, MIN( DTFAC, FACMAX ) )
            ELSE
               DTFAC = MAX( FACMIN, MIN( DTFAC, FACONE ) )
            END IF 
            !CALL SYNCTHREADS()

            !DTOLD = DT
            !DTNEW = MIN( DTMAX, MAX( DTMIN, DTFAC * DT ) )
            !DT = DTNEW
            !ISTAT = ATOMICCAS( DT, DTOLD, DTNEW )
            DT = MIN( DTMAX, MAX( DTMIN, DTFAC * DT ) )
            !IF ( IX .EQ. 1 ) DT = MIN( DTMAX, MAX( DTMIN, DTFAC * DT ) )

            !CALL SYNCTHREADS()            
            LPASS = .TRUE.

        ELSE

            !DTOLD = DT
            !DTNEW = FACMIN * DT
            !DT = DTNEW
            !ISTAT = ATOMICCAS( DT, DTOLD, DTNEW )
            DT = FACMIN * DT
            !IF ( IX .EQ. 1 ) DT = FACMIN * DT

            !CALL SYNCTHREADS()
            LPASS = .FALSE.

        END IF
      CALL SYNCTHREADS()
100 END DO
   !LPASS = LPASS_LOC
   CALL SYNCTHREADS()
   RETURN
END SUBROUTINE RBKERNEL
   
END MODULE RBROUTINES

SUBROUTINE KERNELDRIVER( BLKSIZE, Y, RKI, DTSTART, &
                        CHEMSTEP, NCSP, LORDERING, ISCHAN,   &
                        IDIAGBEG, DT, TNOW, LPASS, OFFSET,   &
                        ATOL, RTOL, ERRMX2, RGAM, IARRAY,    &
                        NUMCELLS, N_SPEC, C21, C31, &
                        C32, B1, B2, B3, D1, D2, D3, UROUND, &
                        GROW, CONMIN, FACMIN, FACMAX, &
                        FACONE, DTMAX, DTMIN, MXCELLS, NCS2,  &
                        NUMB_MECH_SPC, RNSPEC, NUSERAT,      &
                        NKUSERAT, NREACT, IRM2, NPRDCT, SC,  &
                        NRXNS, MXRCT, MXPRD, MXRR, MXRP, NDERIVL, &
                        JARRL, JLIAL, NDERIVP, JARRP, JPIAL, ICOEFF, JZLO, IDEC1LO, &
                        IDEC1HI, MXCOUNT2, IJDECA, IJDECB, &
                        IKDECA, IKDECB, KJDECA, KJDECB, JARRAYPT, &
                        JHIZ1, JHIZ2, MXARRAY, JZEROA, JZEROB, &
                        KZHI0, KZERO, KZLO1, KZHI1, KZLO2, &
                        KZILCH, MZHI0, MZLO1, MZHI1, MZLO2, MZILCH, NCS, MPI_COMM_WORLD, &
                        BLKTEMP, BLKDENS, NSPECIAL_RXN )

   USE RBROUTINES
   USE CUDAFOR

   IMPLICIT NONE

!   Arguments
   INTEGER :: BLKSIZE
   REAL( 8 ) :: Y( BLKSIZE, NUMB_MECH_SPC )
   REAL( 8 ) :: RKI( BLKSIZE, NRXNS )
   REAL( 8 ) :: DTSTART
   REAL( 8 ) :: CHEMSTEP
   INTEGER :: NCSP
   LOGICAL :: LORDERING
   INTEGER :: ISCHAN
   INTEGER :: IDIAGBEG
   REAL( 8 ) :: DT
   REAL( 8 ) :: TNOW
   LOGICAL :: LPASS
   INTEGER :: OFFSET
   REAL( 8 ) :: ATOL( NUMB_MECH_SPC )
   REAL( 8 ) :: RTOL( NUMB_MECH_SPC )
   REAL( 8 ) :: ERRMX2( MXCELLS )
   REAL( 8 ) :: RGAM
   INTEGER :: IARRAY( NCS2 )
   !INTEGER :: BLKSIZE
   INTEGER :: NUMCELLS
   INTEGER :: N_SPEC
   REAL( 8 ) :: C21
   REAL( 8 ) :: C31
   REAL( 8 ) :: C32
   REAL( 8 ) :: B1
   REAL( 8 ) :: B2
   REAL( 8 ) :: B3
   REAL( 8 ) :: D1
   REAL( 8 ) :: D2
   REAL( 8 ) :: D3
   REAL( 8 ) :: UROUND
   REAL( 8 ) :: GROW
   REAL( 8 ) :: CONMIN
   REAL( 8 ) :: FACMIN
   REAL( 8 ) :: FACMAX
   REAL( 8 ) :: FACONE
   REAL( 8 ) :: DTMAX
   REAL( 8 ) :: DTMIN
   INTEGER :: MXCELLS
   INTEGER :: NCS2
   INTEGER :: NUMB_MECH_SPC
   REAL( 8 ) :: RNSPEC
   INTEGER :: NUSERAT( NCS2 )
   INTEGER :: NKUSERAT( NRXNS, NCS2 )
   INTEGER :: NREACT( NRXNS )
   INTEGER :: IRM2( NRXNS,MXRCT+MXPRD,NCS2 )
   INTEGER :: NPRDCT( NRXNS )
   REAL( 8 ) :: SC( NRXNS, MXPRD )
   INTEGER :: NRXNS
   INTEGER :: MXRCT
   INTEGER :: MXPRD
   INTEGER :: MXRR
   INTEGER :: MXRP
   INTEGER :: NDERIVL( NRXNS, NCS2 )
   INTEGER :: JARRL( NRXNS, MXRR, NCS2 )
   INTEGER :: JLIAL( NRXNS, MXRR, NCS2 )
   INTEGER :: NDERIVP( NRXNS, NCS2 )
   INTEGER :: JARRP( NRXNS, MXRP, NCS2 )
   INTEGER :: JPIAL( NRXNS, MXRP, NCS2 )
   INTEGER :: ICOEFF( NRXNS, MXRP, NCS2 )
   INTEGER :: JZLO( NCS2 )
   INTEGER :: IDEC1LO( NUMB_MECH_SPC, NCS2 )
   INTEGER :: IDEC1HI( NUMB_MECH_SPC, NCS2 )
   INTEGER :: MXCOUNT2
   INTEGER :: IJDECA( MXCOUNT2 )
   INTEGER :: IJDECB( MXCOUNT2 )
   INTEGER :: IKDECA( MXCOUNT2 )
   INTEGER :: IKDECB( MXCOUNT2 )
   INTEGER :: KJDECA( MXCOUNT2 )
   INTEGER :: KJDECB( MXCOUNT2 )
   INTEGER :: JARRAYPT( NUMB_MECH_SPC, NUMB_MECH_SPC, NCS2 )
   INTEGER :: JHIZ1( NUMB_MECH_SPC, NCS2 )
   INTEGER :: JHIZ2( NUMB_MECH_SPC, NCS2 )
   INTEGER :: MXARRAY
   INTEGER :: JZEROA( MXARRAY )
   INTEGER :: JZEROB( MXARRAY )
   INTEGER :: KZHI0( NUMB_MECH_SPC, NCS2 )
   INTEGER :: KZERO( MXARRAY, NCS2 )
   INTEGER :: KZLO1( NUMB_MECH_SPC, NCS2 )
   INTEGER :: KZHI1( NUMB_MECH_SPC, NCS2 )
   INTEGER :: KZLO2( NUMB_MECH_SPC, NCS2 )
   INTEGER :: KZILCH( NUMB_MECH_SPC, NCS2 )
   INTEGER :: MZHI0( NUMB_MECH_SPC, NCS2 )
   INTEGER :: MZLO1( NUMB_MECH_SPC, NCS2 )
   INTEGER :: MZHI1( NUMB_MECH_SPC, NCS2 )
   INTEGER :: MZLO2( NUMB_MECH_SPC, NCS2 )
   INTEGER :: MZILCH( NUMB_MECH_SPC, NCS2 )
   INTEGER :: NCS
   INTEGER :: MPI_COMM_WORLD
   REAL( 8 ) :: BLKTEMP( BLKSIZE )
   REAL( 8 ) :: BLKDENS( BLKSIZE )
   INTEGER :: NSPECIAL_RXN
!   Local variables
   TYPE( DIM3 ) :: GRID, TBLOCK
   INTEGER :: ISTAT, MPCOUNT, MAXTHREADS, MAXBLOCKS, MAXWARPS
   TYPE( CUDADEVICEPROP ) :: PROP
   INTEGER :: IERROR, RANK, NPROCS, NDEV, DEVID
   INTEGER( KIND=CUDA_STREAM_KIND ) :: STREAMID
!  Timing
   !REAL START, FINISH

   !CALL MPI_BARRIER( MPI_COMM_WORLD, IERROR )
   !PRINT *, "NKUSERAT ", SIZEOF( NKUSERAT )
   !PRINT *, "NCS2 ", NCS2

   CALL MPI_COMM_RANK( MPI_COMM_WORLD, RANK, IERROR )
   CALL MPI_COMM_SIZE( MPI_COMM_WORLD, NPROCS, IERROR )

   ISTAT = cudaGetDeviceCount( NDEV )
   DEVID = MOD( RANK,NDEV )
   ISTAT = cudaSetDevice( DEVID )

   ISTAT = cudaStreamCreate( STREAMID )
   !STREAMID = cudaStreamPerThread

   ALLOCATE( &
      ATOL_D( NUMB_MECH_SPC ), &
      RTOL_D( NUMB_MECH_SPC ), &
      ERRMX2_D( MXCELLS ), &
      IARRAY_D( NCS2 ), &
      NUSERAT_D( NCS2 ), &
      NKUSERAT_D( NRXNS, NCS2 ), &
      NREACT_D( NRXNS ), &
      IRM2_D( NRXNS,MXRCT+MXPRD,NCS2 ), &
      NPRDCT_D( NRXNS ), &
      SC_D( NRXNS, MXPRD ), &
      NDERIVL_D( NRXNS, NCS2 ), &
      JARRL_D( NRXNS, MXRR, NCS2 ), &
      JLIAL_D( NRXNS, MXRR, NCS2 ), &
      NDERIVP_D( NRXNS, NCS2 ), &
      JARRP_D( NRXNS, MXRP, NCS2 ), &
      JPIAL_D( NRXNS, MXRP, NCS2 ), &
      ICOEFF_D( NRXNS, MXRP, NCS2 ), &
      JZLO_D( NCS2 ), &
      IDEC1LO_D( NUMB_MECH_SPC, NCS2 ), &
      IDEC1HI_D( NUMB_MECH_SPC, NCS2 ), &
      IJDECA_D( MXCOUNT2 ), &
      IJDECB_D( MXCOUNT2 ), &
      IKDECA_D( MXCOUNT2 ), &
      IKDECB_D( MXCOUNT2 ), &
      KJDECA_D( MXCOUNT2 ), &
      KJDECB_D( MXCOUNT2 ), &
      JARRAYPT_D( NUMB_MECH_SPC, NUMB_MECH_SPC, NCS2 ), &
      JHIZ1_D( NUMB_MECH_SPC, NCS2 ), &
      JHIZ2_D( NUMB_MECH_SPC, NCS2 ), &
      JZEROA_D( MXARRAY ), &
      JZEROB_D( MXARRAY ), &
      KZHI0_D( NUMB_MECH_SPC, NCS2 ), &
      KZERO_D( MXARRAY, NCS2 ), &
      KZLO1_D( NUMB_MECH_SPC, NCS2 ), &
      KZHI1_D( NUMB_MECH_SPC, NCS2 ), &
      KZLO2_D( NUMB_MECH_SPC, NCS2 ), &
      KZILCH_D( NUMB_MECH_SPC, NCS2 ), &
      MZHI0_D( NUMB_MECH_SPC, NCS2 ), &
      MZLO1_D( NUMB_MECH_SPC, NCS2 ), &
      MZHI1_D( NUMB_MECH_SPC, NCS2 ), &
      MZLO2_D( NUMB_MECH_SPC, NCS2 ), &
      MZILCH_D( NUMB_MECH_SPC, NCS2 ), &
      EXPLIC( BLKSIZE,3 ), &
      ERR( BLKSIZE ), &
      Y_D( BLKSIZE, NUMB_MECH_SPC ), &
      YDOT_D( BLKSIZE, NUMB_MECH_SPC ), &
      YP_D( BLKSIZE, NUMB_MECH_SPC ), &
      K1_D( BLKSIZE, N_SPEC ), &
      K2_D( BLKSIZE, N_SPEC ), &
      K3_D( BLKSIZE, N_SPEC ), & 
      RKI_D( BLKSIZE, NRXNS ), & 
      RXRAT_D( BLKSIZE, NRXNS ), &
      CC2_D( BLKSIZE, 0:MXARRAY ), &
      VDIAG_D( BLKSIZE, NUMB_MECH_SPC ), &
      BLKTEMP_D( BLKSIZE ), &
      BLKDENS_D( BLKSIZE ) &
      !ERRYMAX( BLKSIZE ), &
      !YTOL( BLKSIZE ) &
   )

   !CALL MPI_BARRIER( MPI_COMM_WORLD, IERROR )

   !CALL CPU_TIME( START )

   !CHEMSTEP_D = CHEMSTEP
   !NCS_D = NCS
   !NCSP_D = NCSP
   !LORDERING_D = LORDERING
   !ISCHAN_D = ISCHAN
   !IDIAGBEG_D = IDIAGBEG
   !DT_D = DT
   !TNOW_D = TNOW
   !LPASS_D = LPASS
   !OFFSET_D = OFFSET
   !RGAM_D = RGAM
   !BLKSIZE_D = BLKSIZE
   !NUMCELLS_D = NUMCELLS
   !N_SPEC_D = N_SPEC
   !C21_D = C21
   !C31_D = C31
   !C32_D = C32
   !B1_D = B1
   !B2_D = B2
   !B3_D = B3
   !D1_D = D1
   !D2_D = D2
   !D3_D = D3
   !UROUND_D = UROUND
   !GROW_D = GROW
   !CONMIN_D = CONMIN
   !FACMIN_D = FACMIN
   !FACMAX_D = FACMAX
   !FACONE_D = FACONE
   !DTMAX_D = DTMAX
   !DTMIN_D = DTMIN
   !MXCELLS_D = MXCELLS
   !NCS2_D = NCS2
   !NUMB_MECH_SPC_D = NUMB_MECH_SPC
   !RNSPEC_D = RNSPEC
   !NRXNS_D = NRXNS
   !MXRCT_D = MXRCT
   !MXPRD_D = MXPRD
   !MXRR_D = MXRR
   !MXRP_D = MXRP
   !MXCOUNT2_D = MXCOUNT2
   !MXARRAY_D = MXARRAY

   ATOL_D = ATOL
   !ISTAT = cudaMemcpyAsync( ATOL_D, ATOL, SIZE( ATOL ), STREAMID )
   RTOL_D = RTOL
   !ISTAT = cudaMemcpyAsync( RTOL_D, RTOL, SIZE( RTOL ), STREAMID )
   ERRMX2_D = ERRMX2
   !ISTAT = cudaMemcpyAsync( ERRMX2_D, ERRMX2, SIZE( ERRMX2 ), STREAMID )
   IARRAY_D = IARRAY
   !ISTAT = cudaMemcpyAsync( IARRAY_D, IARRAY, SIZE( IARRAY ), STREAMID )
   NUSERAT_D = NUSERAT
   !ISTAT = cudaMemcpyAsync( NUSERAT_D, NUSERAT, SIZE( NUSERAT ), STREAMID )
   NKUSERAT_D = NKUSERAT
   !ISTAT = cudaMemcpyAsync( NKUSERAT_D, NKUSERAT, SIZE( NKUSERAT ), STREAMID )
   NREACT_D = NREACT
   !ISTAT = cudaMemcpyAsync( NREACT_D, NREACT, SIZE( NREACT ), STREAMID )
   IRM2_D = IRM2
   !ISTAT = cudaMemcpyAsync( IRM2_D, IRM2, SIZE( IRM2 ), STREAMID )
   NPRDCT_D = NPRDCT
   !ISTAT = cudaMemcpyAsync( NPRDCT_D, NPRDCT, SIZE( NPRDCT ), STREAMID )
   SC_D = SC
   !ISTAT = cudaMemcpyAsync( SC_D, SC, SIZE( SC ), STREAMID )
   NDERIVL_D = NDERIVL
   !ISTAT = cudaMemcpyAsync( NDERIVL_D, NDERIVL, SIZE( NDERIVL ), STREAMID )
   JARRL_D = JARRL
   !ISTAT = cudaMemcpyAsync( JARRL_D, JARRL, SIZE( JARRL ), STREAMID )
   JLIAL_D = JLIAL
   !ISTAT = cudaMemcpyAsync( JLIAL_D, JLIAL, SIZE( JLIAL ), STREAMID )
   NDERIVP_D = NDERIVP
   !ISTAT = cudaMemcpyAsync( NDERIVP_D, NDERIVP, SIZE( NDERIVP ), STREAMID )
   JARRP_D = JARRP
   !ISTAT = cudaMemcpyAsync( JARRP_D, JARRP, SIZE( JARRP ), STREAMID )
   JPIAL_D = JPIAL
   !ISTAT = cudaMemcpyAsync( JPIAL_D, JPIAL, SIZE( JPIAL ), STREAMID )
   ICOEFF_D = ICOEFF
   !ISTAT = cudaMemcpyAsync( ICOEFF_D, ICOEFF, SIZE( ICOEFF ), STREAMID )
   JZLO_D = JZLO
   !ISTAT = cudaMemcpyAsync( JZLO_D, JZLO, SIZE( JZLO ), STREAMID )
   IDEC1LO_D = IDEC1LO
   !ISTAT = cudaMemcpyAsync( IDEC1LO_D, IDEC1LO, SIZE( IDEC1LO ), STREAMID )
   IDEC1HI_D = IDEC1HI
   !ISTAT = cudaMemcpyAsync( IDEC1HI_D, IDEC1HI, SIZE( IDEC1HI ), STREAMID )
   IJDECA_D = IJDECA
   !ISTAT = cudaMemcpyAsync( IJDECA_D, IJDECA, SIZE( IJDECA ), STREAMID )
   IJDECB_D = IJDECB
   !ISTAT = cudaMemcpyAsync( IJDECB_D, IJDECB, SIZE( IJDECB ), STREAMID )
   IKDECA_D = IKDECA
   !ISTAT = cudaMemcpyAsync( IKDECA_D, IKDECA, SIZE( IKDECA ), STREAMID )
   IKDECB_D = IKDECB
   !ISTAT = cudaMemcpyAsync( IKDECB_D, IKDECB, SIZE( IKDECB ), STREAMID )
   KJDECA_D = KJDECA
   !ISTAT = cudaMemcpyAsync( KJDECA_D, KJDECA, SIZE( KJDECA ), STREAMID )
   KJDECB_D = KJDECB
   !ISTAT = cudaMemcpyAsync( KJDECB_D, KJDECB, SIZE( KJDECB ), STREAMID )
   JARRAYPT_D = JARRAYPT
   !ISTAT = cudaMemcpyAsync( JARRAYPT_D, JARRAYPT, SIZE( JARRAYPT ), STREAMID )
   JHIZ1_D = JHIZ1
   !ISTAT = cudaMemcpyAsync( JHIZ1_D, JHIZ1, SIZE( JHIZ1 ), STREAMID )
   JHIZ2_D = JHIZ2
   !ISTAT = cudaMemcpyAsync( JHIZ2_D, JHIZ2, SIZE( JHIZ2 ), STREAMID )
   JZEROA_D = JZEROA
   !ISTAT = cudaMemcpyAsync( JZEROA_D, JZEROA, SIZE( JZEROA ), STREAMID )
   JZEROB_D = JZEROB
   !ISTAT = cudaMemcpyAsync( JZEROB_D, JZEROB, SIZE( JZEROB ), STREAMID )
   KZHI0_D = KZHI0
   !ISTAT = cudaMemcpyAsync( KZHI0_D, KZHI0, SIZE( KZHI0 ), STREAMID )
   KZERO_D = KZERO
   !ISTAT = cudaMemcpyAsync( KZERO_D, KZERO, SIZE( KZERO ), STREAMID )
   KZLO1_D = KZLO1
   !ISTAT = cudaMemcpyAsync( KZLO1_D, KZLO1, SIZE( KZLO1 ), STREAMID )
   KZHI1_D = KZHI1
   !ISTAT = cudaMemcpyAsync( KZHI1_D, KZHI1, SIZE( KZHI1 ), STREAMID )
   KZLO2_D = KZLO2
   !ISTAT = cudaMemcpyAsync( KZLO2_D, KZLO2, SIZE( KZLO2 ), STREAMID )
   KZILCH_D = KZILCH
   !ISTAT = cudaMemcpyAsync( KZILCH_D, KZILCH, SIZE( KZILCH ), STREAMID )
   MZHI0_D = MZHI0
   !ISTAT = cudaMemcpyAsync( MZHI0_D, MZHI0, SIZE( MZHI0 ), STREAMID )
   MZLO1_D = MZLO1
   !ISTAT = cudaMemcpyAsync( MZLO1_D, MZLO1, SIZE( MZLO1 ), STREAMID )
   MZHI1_D = MZHI1
   !ISTAT = cudaMemcpyAsync( MZHI1_D, MZHI1, SIZE( MZHI1 ), STREAMID )
   MZLO2_D = MZLO2
   !ISTAT = cudaMemcpyAsync( MZLO2_D, MZLO2, SIZE( MZLO2 ), STREAMID )
   MZILCH_D = MZILCH
   !ISTAT = cudaMemcpyAsync( MZILCH_D, MZILCH, SIZE( MZILCH ), STREAMID )

   BLKTEMP_D = BLKTEMP
   !ISTAT = cudaMemcpyAsync( BLKTEMP_D, BLKTEMP, SIZE( BLKTEMP ), STREAMID )
   BLKDENS_D = BLKDENS
   !ISTAT = cudaMemcpyAsync( BLKDENS_D, BLKDENS, SIZE( BLKDENS ), STREAMID )

   Y_D = Y
   !ISTAT = cudaMemcpyAsync( Y_D, Y, SIZE( Y ), STREAMID )
   !YDOT_D = YDOT
   !YP_D = YP
   !K1_D = K1
   !K2_D = K2
   !K3_D = K3
   RKI_D = RKI
   !ISTAT = cudaMemcpyAsync( RKI_D, RKI, SIZE( RKI ), STREAMID )
   !RXRAT_D = RXRAT
   !CC2_D = CC2
   !VDIAG_D = VDIAG

   !CALL CPU_TIME( FINISH )
   !PRINT *, 'COPY TO DEVICE TIME: ', FINISH - START

   ISTAT = cudaGetDeviceProperties( PROP, DEVID )
   MPCOUNT = PROP%multiProcessorCount
   MAXTHREADS = PROP%maxThreadsPerMultiProcessor
   MAXBLOCKS = PROP%maxBlocksPerMultiProcessor

   GRID = DIM3( MAXBLOCKS*MPCOUNT*NDEV/NPROCS,1,1 )
   TBLOCK = DIM3( MAXTHREADS/MAXBLOCKS,1,1 )

   !ISTAT = cudaDeviceSynchronize()
   ISTAT = cudaStreamSynchronize( STREAMID )

   CALL RBKERNEL<<< GRID,TBLOCK,0,STREAMID >>>( CHEMSTEP, NCSP, LORDERING, ISCHAN,   &
                                                IDIAGBEG, DTSTART, OFFSET,   &
                                                BLKSIZE, NUMCELLS, N_SPEC, C21, C31, &
                                                C32, B1, B2, B3, D1, D2, D3, UROUND, &
                                                GROW, CONMIN, FACMIN, FACMAX, &
                                                FACONE, DTMAX, DTMIN, MXCELLS, NCS2,  &
                                                NUMB_MECH_SPC, RNSPEC, RGAM, &
                                                NRXNS, MXRCT, MXPRD, MXRR, MXRP, &
                                                MXCOUNT2, MXARRAY, NCS, &
                                                NSPECIAL_RXN )

   ISTAT = cudaStreamSynchronize( STREAMID )
   !ISTAT = cudaDeviceSynchronize()
   
   ISTAT = cudaGetLastError()
   IF ( ISTAT .NE. cudaSuccess ) PRINT *, cudaGetErrorString( ISTAT )

   !PRINT *, "KERNEL COMPLETE."

   !CALL CPU_TIME( FINISH )

      !PRINT *, 'ROSENBROCK ITERATION TIME: ', FINISH - START

      !IF ( LORDERING ) EXIT

      !TNOW = TNOW_D
      
   !END DO

   !CALL MPI_BARRIER( MPI_COMM_WORLD, IERROR )

   !PRINT *, 'KERNEL TIME: ', FINISH - START
   !CALL CPU_TIME( START )

   !DT = DT_D
   !TNOW = TNOW_D
   !LPASS = LPASS_D
   !ATOL = ATOL_D
   !RTOL = RTOL_D
   ERRMX2 = ERRMX2_D
   !ISTAT = cudaMemcpyAsync( ERRMX2, ERRMX2_D, SIZE( ERRMX2 ), STREAMID )
   !IARRAY = IARRAY_D
   !NUSERAT = NUSERAT_D
   !NKUSERAT = NKUSERAT_D
   !NREACT = NREACT_D
   !IRM2 = IRM2_D
   !NPRDCT = NPRDCT_D
   !SC = SC_D
   !NDERIVL = NDERIVL_D
   !JARRL = JARRL_D
   !JLIAL = JLIAL_D
   !NDERIVP = NDERIVP_D
   !JARRP = JARRP_D
   !JPIAL = JPIAL_D
   !ICOEFF = ICOEFF_D
   !JZLO = JZLO_D
   !IDEC1LO = IDEC1LO_D
   !IDEC1HI = IDEC1HI_D
   !IJDECA = IJDECA_D
   !IJDECB = IJDECB_D
   !IKDECA = IKDECA_D
   !IKDECB = IKDECB_D
   !KJDECA = KJDECA_D
   !KJDECB = KJDECB_D
   !JARRAYPT = JARRAYPT_D
   !JHIZ1 = JHIZ1_D
   !JHIZ2 = JHIZ2_D
   !JZEROA = JZEROA_D
   !JZEROB = JZEROB_D
   !KZHI0 = KZHI0_D
   !KZERO = KZERO_D
   !KZLO1 = KZLO1_D
   !KZHI1 = KZHI1_D
   !KZLO2 = KZLO2_D
   !KZILCH = KZILCH_D
   !MZHI0 = MZHI0_D
   !MZLO1 = MZLO1_D
   !MZHI1 = MZHI1_D
   !MZLO2 = MZLO2_D
   !MZILCH = MZILCH_D

   Y = Y_D
   !ISTAT = cudaMemcpyAsync( Y, Y_D, SIZE( Y ), STREAMID )
   !YDOT = YDOT_D
   !YP = YP_D
   !K1 = K1_D
   !K2 = K2_D
   !K3 = K3_D
   !RKI = RKI_D
   !RXRAT = RXRAT_D
   !CC2 = CC2_D
   !VDIAG = VDIAG_D

   !CALL CPU_TIME( FINISH )
   !PRINT *, 'COPY TO HOST TIME: ', FINISH - START

   !CALL MPI_BARRIER( MPI_COMM_WORLD, IERROR )

   DEALLOCATE( &
      Y_D,  &
      YDOT_D,  &
      YP_D, &
      K1_D, &
      K2_D, &
      K3_D, &
      RKI_D,   &
      RXRAT_D, &
      CC2_D,   &
      VDIAG_D, &
      EXPLIC, &
      ERR, &
      ATOL_D, &
      RTOL_D, &
      ERRMX2_D, &
      IARRAY_D, &
      NUSERAT_D, &
      NKUSERAT_D, &
      NREACT_D, &
      IRM2_D, &
      NPRDCT_D, &
      SC_D, &
      NDERIVL_D, &
      JARRL_D, &
      JLIAL_D, &
      NDERIVP_D, &
      JARRP_D, &
      JPIAL_D, &
      ICOEFF_D, &
      JZLO_D, &
      IDEC1LO_D, &
      IDEC1HI_D, &
      IJDECA_D, &
      IJDECB_D, &
      IKDECA_D, &
      IKDECB_D, &
      KJDECA_D, &
      KJDECB_D, &
      JARRAYPT_D, &
      JHIZ1_D, &
      JHIZ2_D, &
      JZEROA_D, &
      JZEROB_D, &
      KZHI0_D, &
      KZERO_D, &
      KZLO1_D, &
      KZHI1_D, &
      KZLO2_D, &
      KZILCH_D, &
      MZHI0_D, &
      MZLO1_D, &
      MZHI1_D, &
      MZLO2_D, &
      MZILCH_D, &
      BLKTEMP_D, &
      BLKDENS_D &
      !ERRYMAX, &
      !YTOL &
   )

   !ISTAT = cudaStreamDestroy( STREAMID )

   !END IF

   !CALL MPI_BARRIER( MPI_COMM_WORLD, IERROR )

   RETURN

END SUBROUTINE KERNELDRIVER
